/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * java mavlink generator tool. It should not be modified by hand.
 */

package com.MAVLink;

import com.MAVLink.MAVLinkPacket;
import com.MAVLink.Messages.MAVLinkStats;

public class Parser {

    /**
     * States from the parsing state machine
     */
    enum MAV_states {
        MAVLINK_PARSE_STATE_UNINIT,
        MAVLINK_PARSE_STATE_IDLE,
        MAVLINK_PARSE_STATE_GOT_STX,
        MAVLINK_PARSE_STATE_GOT_STX_MAVLINK1,
        MAVLINK_PARSE_STATE_GOT_LENGTH,
        MAVLINK_PARSE_STATE_GOT_SEQ,
        MAVLINK_PARSE_STATE_GOT_INCOMPAT_FLAGS,
        MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS,
        MAVLINK_PARSE_STATE_GOT_SYSID,
        MAVLINK_PARSE_STATE_GOT_COMPID,
        MAVLINK_PARSE_STATE_GOT_MSGID1,
        MAVLINK_PARSE_STATE_GOT_MSGID2,
        MAVLINK_PARSE_STATE_GOT_MSGID3,
        MAVLINK_PARSE_STATE_GOT_CRC1,
        MAVLINK_PARSE_STATE_GOT_PAYLOAD
    }

    MAV_states state = MAV_states.MAVLINK_PARSE_STATE_UNINIT;

    public MAVLinkStats stats;
    private MAVLinkPacket m;

    public Parser() {
        this(false);
    }

    public Parser(boolean ignoreRadioPacketStats) {
        stats = new MAVLinkStats(ignoreRadioPacketStats);
    }

    /**
     * This is a convenience function which handles the complete MAVLink
     * parsing. the function will parse one byte at a time and return the
     * complete packet once it could be successfully decoded. Checksum and other
     * failures will be silently ignored.
     * 
     * @param c
     *            The char to parse
     */
    public MAVLinkPacket mavlink_parse_char(int c) {
        c &= 0xff; // cast to byte

        switch (state) {
        case MAVLINK_PARSE_STATE_UNINIT:
        case MAVLINK_PARSE_STATE_IDLE:

            if (c == MAVLinkPacket.MAVLINK_STX) {
                state = MAV_states.MAVLINK_PARSE_STATE_GOT_STX;
            } else if (c == MAVLinkPacket.MAVLINK_STX_MAVLINK1) {
                state = MAV_states.MAVLINK_PARSE_STATE_GOT_STX_MAVLINK1;
            }
            break;

        case MAVLINK_PARSE_STATE_GOT_STX:
            m = new MAVLinkPacket(c);
            m.setProtocol(MAVLinkPacket.Protocol.PROTOCOL_2_0);
            state = MAV_states.MAVLINK_PARSE_STATE_GOT_LENGTH;
            break;

        case MAVLINK_PARSE_STATE_GOT_STX_MAVLINK1:
            m = new MAVLinkPacket(c);
            m.setProtocol(MAVLinkPacket.Protocol.PROTOCOL_1_0);
            state = MAV_states.MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS;
            break;

        case MAVLINK_PARSE_STATE_GOT_LENGTH:
            m.incompat_flags = c;
            state = MAV_states.MAVLINK_PARSE_STATE_GOT_INCOMPAT_FLAGS;
            break;

        case MAVLINK_PARSE_STATE_GOT_INCOMPAT_FLAGS:
            m.compat_flags = c;
            state = MAV_states.MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS;
            break;

        case MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS:
            m.seq = c;
            state = MAV_states.MAVLINK_PARSE_STATE_GOT_SEQ;
            break;

        case MAVLINK_PARSE_STATE_GOT_SEQ:
            m.sysid = c;
            state = MAV_states.MAVLINK_PARSE_STATE_GOT_SYSID;
            break;

        case MAVLINK_PARSE_STATE_GOT_SYSID:
            m.compid = c;
            state = MAV_states.MAVLINK_PARSE_STATE_GOT_COMPID;
            break;

        case MAVLINK_PARSE_STATE_GOT_COMPID:
            m.msgid = c;
            if (m.protocol == MAVLinkPacket.Protocol.PROTOCOL_2_0) {
                state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID1;
            } else {
                if (m.len == 0) {
                    state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;
                } else {
                    state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID3;
                }
            }
            break;

        case MAVLINK_PARSE_STATE_GOT_MSGID1:
            m.msgid |= (c << 8);
            state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID2;
            break;

        case MAVLINK_PARSE_STATE_GOT_MSGID2:
            m.msgid |= (c << 16);
            if (m.len == 0) {
                state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;
            } else {
                state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID3;
            }
            break;

        case MAVLINK_PARSE_STATE_GOT_MSGID3:
            m.payload.add((byte) c);
            if (m.payloadIsFilled()) {
                state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;
            }
            break;

        case MAVLINK_PARSE_STATE_GOT_PAYLOAD:
            m.generateCRC();
            // Check first checksum byte
            if (c != m.crc.getLSB()) {
                state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
                stats.crcError();
            } else {
                state = MAV_states.MAVLINK_PARSE_STATE_GOT_CRC1;
            }
            break;

        case MAVLINK_PARSE_STATE_GOT_CRC1:
            // Check second checksum byte
            if (c != m.crc.getMSB()) {
                state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
                stats.crcError();
            } else { // Successfully received the message
                stats.newPacket(m);
                state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
                return m;
            }

            break;
        }
        return null;
    }
}
