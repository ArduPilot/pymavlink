/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

import 'package:mavlink/ardupilotmega.dart';
import 'package:mavlink/mavlink.dart';
import 'package:mavlink/src/enums/mav_component.dart';

/// States from the parsing state machine
enum MAV_states {
    MAVLINK_PARSE_STATE_UNINIT,
    MAVLINK_PARSE_STATE_IDLE,
    MAVLINK_PARSE_STATE_GOT_STX,
    MAVLINK_PARSE_STATE_GOT_LENGTH,
    MAVLINK_PARSE_STATE_GOT_INCOMPAT_FLAGS, // MAVLink 2
    MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS, // MAVLink 2
    MAVLINK_PARSE_STATE_GOT_SEQ,
    MAVLINK_PARSE_STATE_GOT_SYSID,
    MAVLINK_PARSE_STATE_GOT_COMPID,
    MAVLINK_PARSE_STATE_GOT_MSGID1,
    MAVLINK_PARSE_STATE_GOT_MSGID2, // MAVLink 2
    MAVLINK_PARSE_STATE_GOT_MSGID3, // MAVLink 2
    MAVLINK_PARSE_STATE_GOT_CRC1,
    MAVLINK_PARSE_STATE_GOT_CRC2, // MAVLink 2
    MAVLINK_PARSE_STATE_GOT_PAYLOAD,
    MAVLINK_PARSE_STATE_GOT_SIGNATURE, // MAVLink 2
}

/// MAVLink parser that parses @{link MAVLinkPacket}s from a byte stream one byte
/// at a time.
///
/// After creating an instance of this class, simply use the @{link #mavlink_parse_char} 
/// method to parse a byte stream.
class Parser {
    Parser();

    static const bool _V = false;
  
    static void _logv(String str) {
        StringBuffer buf = StringBuffer("Parser: ");
        buf.write(str);
        if(_V) print(buf.toString());
    }

    MAV_states _state = MAV_states.MAVLINK_PARSE_STATE_UNINIT;

    MAVLinkStats stats = MAVLinkStats();
    MAVLinkPacket? _m;
    bool _isMavlink2 = false;

    Parser.withIgnoreRadioPackets(bool ignoreRadioPacketStats) {
      stats = MAVLinkStats.withIgnoreRadioPackets(ignoreRadioPacketStats);
    }

    /// This is a convenience function which handles the complete MAVLink
    /// parsing. the function will parse one byte at a time and return the
    /// complete packet once it could be successfully decoded. Checksum and other
    /// failures will be silently ignored.
    /// 
    /// @param c The char to parse
    /// @return the complete @{link MAVLinkPacket} if successfully decoded, else null
    MAVLinkPacket? mavlink_parse_char(int c) {
        // force to 8 bits
        c &= 0xFF;
        switch (_state) {
            case MAV_states.MAVLINK_PARSE_STATE_UNINIT:
            case MAV_states.MAVLINK_PARSE_STATE_IDLE:
                // MAVLink 1 and 2
                if (c == MAVLinkPacket.MAVLINK_STX_MAVLINK2) {
                    _state = MAV_states.MAVLINK_PARSE_STATE_GOT_STX;
                    if (!_isMavlink2) {
                        _isMavlink2 = true;
                        _logv("Turning mavlink2 ON");
                    }
                } else if (c == MAVLinkPacket.MAVLINK_STX_MAVLINK1) {
                    _state = MAV_states.MAVLINK_PARSE_STATE_GOT_STX;
                    if (_isMavlink2) {
                        _isMavlink2 = false;
                        _logv("Turning mavlink2 OFF");
                    }
                }
                break;

            case MAV_states.MAVLINK_PARSE_STATE_GOT_STX:
                // MAVLink 1 and 2
                _m!.len = c;
                if (_isMavlink2) {
                    _state = MAV_states.MAVLINK_PARSE_STATE_GOT_LENGTH;
                } else {
                    _state = MAV_states.MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS;
                }
                break;

            case MAV_states.MAVLINK_PARSE_STATE_GOT_LENGTH:
                // MAVLink 1 and 2
                _m!.incompatFlags = c;
                if (c != 0 && c != 1) {
                    // message includes an incompatible feature flag
                    _state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
                    break;
                }
                _state = MAV_states.MAVLINK_PARSE_STATE_GOT_INCOMPAT_FLAGS;
                break;

            case MAV_states.MAVLINK_PARSE_STATE_GOT_INCOMPAT_FLAGS:
                // MAVLink 2 only
                _m!.compatFlags = c;
                _state = MAV_states.MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS;
                break;

            case MAV_states.MAVLINK_PARSE_STATE_GOT_COMPAT_FLAGS:
                _m!.seq = c;
                _state = MAV_states.MAVLINK_PARSE_STATE_GOT_SEQ;
                break;

            case MAV_states.MAVLINK_PARSE_STATE_GOT_SEQ:
                // back to MAVLink 1 and 2
                _m!.sysID = c;
                _state = MAV_states.MAVLINK_PARSE_STATE_GOT_SYSID;
                break;

            case MAV_states.MAVLINK_PARSE_STATE_GOT_SYSID:
                // MAVLink 1 and 2
                _m!.compID = c;
                _state = MAV_states.MAVLINK_PARSE_STATE_GOT_COMPID;
                break;

            case MAV_states.MAVLINK_PARSE_STATE_GOT_COMPID:
                // MAVLink 1 and 2
                _m!.msgID = c;
                if (_isMavlink2) {
                    _state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID1;
                } else if (_m!.len > 0) {
                    _state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID3;
                } else {
                    _state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;
                }
                break;

            case MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID1:
                // MAVLink 2 only
                _m!.msgID |= c << 8;
                _state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID2;
                break;

            case MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID2:
                // MAVLink 2 only
                _m!.msgID |= c << 16;
                if (_m!.len > 0) {
                    _state = MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID3;
                } else {
                    _state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;
                }
                break;

            case MAV_states.MAVLINK_PARSE_STATE_GOT_MSGID3:
                // back to MAVLink 1 and 2
                _m!.payload.putUnsignedByte(MAVUint8(c));
                if (_m!.payloadIsFilled()) {
                    _state = MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD;
                }
                break;

            case MAV_states.MAVLINK_PARSE_STATE_GOT_PAYLOAD:
                bool crcGen = _m!.generateCRC(_m!.payload.size());
                // Check first checksum byte and verify the CRC was successfully generated (msg extra exists)
                if (c != _m!.crc.getLSB() || !crcGen) {
                    _state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
                    stats.crcError();
                } else {
                    _state = MAV_states.MAVLINK_PARSE_STATE_GOT_CRC1;
                }
                break;

            case MAV_states.MAVLINK_PARSE_STATE_GOT_CRC1:
                // Check second checksum byte
                if (c != _m!.crc.getMSB()) {
                    _state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
                    stats.crcError();
                } else { // crc is good
                    stats.newPacket(_m!);
                    
                    if (!_isMavlink2 || (_m!.incompatFlags != 0x01)) {
                        // If no signature, then return the message.
                        _state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
                        return _m;
                    } else {
                        // TODO: MAVLink 2 - signed
                        _state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
                        stats.crcError();
                    }
                }
                break;
                
            case MAV_states.MAVLINK_PARSE_STATE_GOT_CRC2:
                // TODO: implement signature parsing and validation
                _state = MAV_states.MAVLINK_PARSE_STATE_IDLE;
                stats.crcError();
                break;
            case MAV_states.MAVLINK_PARSE_STATE_GOT_SIGNATURE:
                break;
        } // switch
        return null;
    }
}
