#!/usr/bin/env python
'''
Parse a MAVLink protocol XML file and generate a Dart implementation

Copyright Andrew Tridgell 2011
Released under GNU GPL version 3 or later
'''
from __future__ import print_function
import array

from builtins import range
from builtins import object
from operator import mod

import os
from . import mavparse, mavtemplate

t = mavtemplate.MAVTemplate()

def generate_enums(basename, xml):
    '''generate main header per XML file'''
    directory = os.path.join(basename, 'lib/src', '''enums''')
    mavparse.mkdir_p(directory)
    for en in xml.enum:
        f = open(os.path.join(directory, en.name.lower()+".dart"), mode='w')
        t.write(f, '''
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

/**
 * ${description}
 */
class ${name} {
${{entry:   static final int ${name} = ${value}; /* ${description} |${{param:${description}| }} */
}}
}
            ''', en)
        f.close()


def generate_platform_exports(directory, messages):
    '''generate export definition'''
    f = open(os.path.join(directory, "export.dart"), mode='w')
    t.write(f, '''
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

library mavlink;

export 'crc.dart';
''')
    for m in messages:
        t.write(f, "export 'msg_%s.dart';\n" % m.name_lower)

    f.close()

def generate_package_exports(directory, basename):
    with open(os.path.join(directory, basename + '.dart'), mode='w') as f:
        t.write(f, '''
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

library mavlink;

export 'src/%s/export.dart';
''' % basename)


def generate_CRC(directory, xml):
    '''generate CRC definition and crc array per dialect'''
    xml.message_crcs_array = ''
    for msgID, crc in sorted(xml.message_crcs.items()):
        xml.message_crcs_array += '%u: %u,\n      ' % (msgID, crc)

    f = open(os.path.join(directory, "crc.dart"), mode='w')
    t.write(f, '''
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

import 'dart:collection';

/**
 * CRC-16/MCRF4XX calculation for MAVlink messages. The checksum must be
 * initialized, updated with which field of the message, and then finished with
 * the message id.
 *
 */
class ${basename}_CRC {
    static const Map<int, int> MAVLINK_MESSAGE_CRCS = const {
      ${message_crcs_array}
    };
    static final int _CRC_INIT_VALUE = 0xffff;
    int _crcValue = _CRC_INIT_VALUE;

    /**
     * Accumulate the CRC by adding one char at a time.
     *
     * The checksum function adds the hash of one char at a time to the 16 bit
     * checksum (uint16_t).
     *
     * @param data new char to hash
     **/
    void update_checksum(int? data) {
        if (data == null) return;
        data = data & 0xff; //cast because we want an unsigned type
        int tmp = data ^ (_crcValue & 0xff);
        tmp ^= (tmp << 4) & 0xff;
        _crcValue = ((_crcValue >> 8) & 0xff) ^ (tmp << 8) ^ (tmp << 3) ^ ((tmp >> 4) & 0xf);
    }

    /**
     * Finish the CRC calculation of a message, by running the CRC with the
     * Magic Byte.
     *
     * @param msgID The message id number
     * @return bool True if the checksum was successfully finished. Otherwise false
     */
    bool finish_checksum(int msgID) {
        if (MAVLINK_MESSAGE_CRCS.containsKey(msgID)) {
            update_checksum(MAVLINK_MESSAGE_CRCS[msgID]);
            return true;
        }
        return false;
    }

    /**
     * Initialize the buffer for the CRC16/MCRF4XX
     */
    void start_checksum() {
        _crcValue = _CRC_INIT_VALUE;
    }

    int getMSB() {
        return ((_crcValue >> 8) & 0xff);
    }

    int getLSB() {
        return (_crcValue & 0xff);
    }
}
''', xml)

    f.close()


def generate_message_h(directory, m):
    '''generate per-message header for a XML file'''
    f = open(os.path.join(directory, 'MSG_%s.dart' % m.name), mode='w')

    (path_head, path_tail) = os.path.split(directory)
    if path_tail == "":
        (path_head, path_tail) = os.path.split(path_head)
    t.write(f, '''
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

// MESSAGE ${name} PACKING
import 'dart:math';

import 'package:mavlink/mavlink.dart';

/**
 * ${description}
 */
class MSG_${name} extends MAVLinkMessage {

    static const int MAVLINK_MSG_ID_${name} = ${id};
    static const int MAVLINK_MSG_LENGTH = ${wire_length};
''', m)

    for item in m.ordered_fields:
        t.write(f, '''

    /**
    * ${description}
    */
    static final String ${name}_description = "${description}";
    static final String ${name}_units = "${units}";
''', item)
        if item.array_length == 0:
            if item.type == 'MAVUint64' or item.type == 'MAVInt64':
                t.write(f, '''
    ${type} _${name} = BigInt.zero;
''', item)
            else:
                t.write(f, '''
    ${type} _${name} = 0;
''', item)
            if item.origType != "char":
                t.write(f, '''
        ${type} get ${name} => _${name};
        void set ${name}(${type} setterData) {
            _${name} = setterData;
        }
''', item)
        else:
            if item.type == 'MAVUint64' or item.type == 'MAVInt64':
                t.write(f, '''
    final List<${type}> _${name} = List<${type}>.filled(${array_length}, BigInt.from(0), growable: false);
''', item)
            else:
                t.write(f, '''
    final List<${type}> _${name} = List<${type}>.filled(${array_length}, 0, growable: false);
''', item)
            if item.origType != "char":
                t.write(f, '''
    List<${type}> get ${name} => _${name};
    void set ${name}(List<${type}> setter) {
        if (setter.length > ${array_length}) {
          var buf = StringBuffer("Provided List<${type}> for ${name} longer than allowed. Max ");
          buf.write(${array_length});
          buf.write(", provided: ");
          buf.write(setter.length);
          throw ArgumentError(buf.toString());
        }
        for (int i=0; i<setter.length; i++) {
          _${name}[i] = setter.elementAt(i);
        }
        if (setter.length < ${array_length}) {
          for (int i=setter.length; i<${array_length}; i++) {
''', item)
                if item.type == 'MAVUint64' or item.type == 'MAVInt64':
                    t.write(f, '''
            _${name}[i] = BigInt.zero;
''', item)
                else:
                    t.write(f, '''
            _${name}[i] = 0;
''', item)
                t.write(f, '''
          }
        }
    }
''', item)
    t.write(f, '''
    /**
     * Generates the payload for a mavlink message for a message of this type
     * @return
     */
    @override
    MAVLinkPacket pack(int seq) {
        MAVLinkPacket packet = MAVLinkPacket(len: MAVLINK_MSG_LENGTH, sysID: sysID, compID: compID, msgID: MAVLINK_MSG_ID_${name}, seq: seq, isMavlink2: isMavlink2);

        ${{base_fields:${packField}
        }}
        if (isMavlink2) {
            ${{extended_fields: ${packField}
            }}
        }
        return packet;
    }

    /**
     * Decode a ${name} message into this class fields
     *
     * @param payload The message to decode
     */
    @override
    void unpack(MAVLinkPayload mavPayload) {
        mavPayload.resetIndex();

        ${{base_fields:${unpackField}
        }}
        if (isMavlink2) {
            ${{extended_fields: ${unpackField}
            }}
        }
    }

    /**
     * Constructor for a new message, just initializes the msgID
     */
    MSG_${name}({required super.compID, required super.sysID, super.isMavlink2 = false}): super(msgID: MAVLINK_MSG_ID_${name}) {
        if (MAVLINK_MSG_ID_${name} > 255) {
            throw new ArgumentError("MSG_${name} is not a valid packet for MAVLink1.");
        }
    }

    MSG_${name}.MAVLink2({required super.compID, required super.sysID}): super(msgID: MAVLINK_MSG_ID_${name}, isMavlink2: true);
''', m)
    t.write(f, '''

    /**
     * Constructor for a new message, initializes the message with the payload
     * from a mavlink packet
     *
     */
    MSG_${name}.fromPacket(MAVLinkPacket mavLinkPacket): super(compID: mavLinkPacket.compID, sysID: mavLinkPacket.sysID, msgID: MAVLINK_MSG_ID_${name}, isMavlink2: mavLinkPacket.isMavlink2) {
        unpack(mavLinkPacket.payload);
    }

    ${{ordered_fields: ${getChar} }}
    ${{ordered_fields: ${getText} }}
    /**
     * Returns a string with the MSG name and data
     */
    @override
    String toString() {
        return "MAVLINK_MSG_ID_${name} - sysID:"+sysID.toString()+" compID:"+compID.toString()+${{ordered_fields:" ${name}:"+${name}.toString()+}}"";
    }

    /**
     * Returns a human-readable string of the name of the message
     */
    @override
    String getMessageName() {
        return "MAVLINK_MSG_ID_${name}";
    }
}
''', m)
    f.close()


def generate_MAVLinkMessage(directory, xml_list):
    f = open(os.path.join(directory, 'lib/src', "mavlink_packet.dart"), mode='w')

    imports = []

    for xml in xml_list:
        importString = "import 'package:mavlink/{}.dart';".format(xml.basename)
        imports.append(importString)

    xml_list[0].importString = '\n'.join(imports)

    t.write(f, '''
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

import 'dart:typed_data';

import 'package:mavlink/mavlink.dart';
${importString}

/**
 * Common interface for all MAVLink Messages
 * Packet Anatomy
 * This is the anatomy of one packet. It is inspired by the CAN and SAE AS-4 standards.
 *
 * MAVLink 1 Packet Format
 *
 * Byte Index  Content              Value       Explanation
 * 0            Packet start sign  v1.0: 0xFE   Indicates the start of a new packet.  (v0.9: 0x55; v1.0: 0xFE; v2.0 0xFD)
 * 1            Payload length      0 - 255     Indicates length of the following payload.
 * 2            Packet sequence     0 - 255     Each component counts up its send sequence. Allows to detect packet loss
 * 3            System ID           1 - 255     ID of the SENDING system. Allows to differentiate different MAVs on the same network.
 * 4            Component ID        0 - 255     ID of the SENDING component. Allows to differentiate different components of the same system, e.g. the IMU and the autopilot.
 * 5            Message ID          0 - 255     ID of the message - the id defines what the payload means and how it should be correctly decoded.
 * 6 to (n+6)   Payload             0 - 255     Data of the message, depends on the message id.
 * (n+7)to(n+8) Checksum (low byte, high byte)  CRC16/MCRF4XX hash, excluding packet start sign, so bytes 1..(n+6) Note: The checksum also includes MAVLINK_CRC_EXTRA (Number computed from message fields. Protects the packet from decoding a different version of the same packet but with different variables).
 *
 * The checksum is the CRC16/MCRF4XX. Please see the MAVLink source code for a documented C-implementation of it. LINK TO CHECKSUM
 * The minimum packet length is 8 bytes for acknowledgement packets without payload
 * The maximum packet length is 263 bytes for full payload
 *
 *
 * MAVLink 2 Packet Format
 *
 * Byte Index     Content             Value              Explanation
 * 0              Packet start sign  v2.0: 0xFD          Indicates the start of a new packet.  (v0.9: 0x55; v1.0: 0xFE; v2.0 0xFD)
 * 1              Payload length      0 - 255            Indicates length of the following payload.
 * 2              Incompatible Flags  0 - 255            Flags that must be understood
 * 3              Compatible Flags    0 - 255            Flags that can be ignored if not understood
 * 4              Packet sequence     0 - 255            Each component counts up its send sequence. Allows to detect packet loss
 * 5              System ID           1 - 255            ID of the SENDING system. Allows to differentiate different MAVs on the same network.
 * 6              Component ID        0 - 255            ID of the SENDING component. Allows to differentiate different components of the same system, e.g. the IMU and the autopilot.
 * 7 to 9         Message ID          0 - 16777216       ID of the message - the id defines what the payload means and how it should be correctly decoded.
 * 10             Target System ID    1 - 255            (OPTIONAL) ID of the TARGET system. Only used for point-to-point mode
 * 11             Target Component ID 0 - 255            (OPTIONAL) ID of the TARGET component. Only used for point-to-point mode
 * 12 to (n+12)   Payload             0 - 255            Data of the message, depends on the message id.
 * (n+13)to(n+14) Checksum (low byte, high byte)         CRC16/MCRF4XX hash, excluding packet start sign, so bytes 1..(n+6) Note: The checksum also includes MAVLINK_CRC_EXTRA (Number computed from message fields. Protects the packet from decoding a different version of the same packet but with different variables).
 * (n+15)to(n+27) Signature (typeid, timestamp, sha256)  (OPTIONAL) Signature which allows ensuring that the link is tamper-proof; 13 bytes containing typeid (1 byte), timestamp (6 bytes), and last 6 bytes of SHA256 hash
 *
 * The signature is a combination of a typeid, timestamp, and SHA256 hash.
 * OPTIONAL fields mean that, if they are not used, they do not exist in the MAVLink frame at all. Typically target sysID and target compID are not used, and signature is only used if signing is set up between both ends.
 *
 * @see <a href="https://mavlink.io">mavlink.io</a> for more documentation on the MAVLink protocol
 */
class MAVLinkPacket {
    static const int MAVLINK_STX_MAVLINK1 = 0xFE; // 254
    static const int MAVLINK_STX_MAVLINK2 = 0xFD; // 253
    static const int MAVLINK1_HEADER_LEN = 6;
    static const int MAVLINK2_HEADER_LEN = 10;
    static const int MAVLINK1_NONPAYLOAD_LEN = MAVLINK1_HEADER_LEN + 2;
    static const int MAVLINK2_NONPAYLOAD_LEN = MAVLINK2_HEADER_LEN + 2;

    static const bool _V = false;

    static void _logv(String str) {
        StringBuffer buf = StringBuffer("MAVLinkPacket: ");
        buf.write(str);
        if(_V) print(buf.toString());
    }

    /**
     * Payload length
     */
    int len;

    /**
     * Message sequence
     */
    int seq;

    /**
     * ID of the SENDING system. Allows to differentiate different MAVs on the
     * same network.
     */
    int sysID;

    /**
     * ID of the SENDING component. Allows to differentiate different components
     * of the same system, e.g. the IMU and the autopilot.
     */
    int compID;

    /**
     * ID of the message - the id defines what the payload means and how it
     * should be correctly decoded.
     */
    int msgID;

    /**
     * Data of the message, depends on the message id.
     */
    MAVLinkPayload payload = MAVLinkPayload();

    /**
    * CRC-16/MCRF4XX hash, excluding packet start sign, so bytes 1..(n+HEADER-LENGTH)
    * Note: The checksum also includes MAVLINK_CRC_EXTRA (Number computed from
    * message fields. Protects the packet from decoding a different version of
    * the same packet but with different variables).
    */
    common_CRC crc = common_CRC();

    // MAVLink 2.0 fields

    /**
     * Flag to indicate which MAVLink version this packet is
     */
    bool isMavlink2;

    /**
     * Flags that must be understood
     */
    int incompatFlags;

    /**
     * Flags that can be ignored if not understood
     */
    int compatFlags;

    MAVLinkPacket({required this.len, required this.sysID, required this.compID, required this.msgID, required this.seq, this.incompatFlags = 0, this.compatFlags = 0, this.isMavlink2 = false});

    MAVLinkPacket.MAVLink2({required this.len, required this.sysID, required this.compID, required this.msgID, required this.seq, this.incompatFlags = 0, this.compatFlags = 0, this.isMavlink2 = true});

    /**
     * Check if the size of the Payload is equal to the "len" byte
     */
    bool payloadIsFilled() {
        return payload.size() >= len;
    }

    /**
     * Update CRC for this packet.
     * @return bool True if the CRC was successfully updated. Otherwise false
     */
    bool generateCRC(final int payloadSize) {
        crc.start_checksum();

        if (isMavlink2) {
            crc.update_checksum(payloadSize);
            crc.update_checksum(incompatFlags);
            crc.update_checksum(compatFlags);
            crc.update_checksum(seq);
            crc.update_checksum(sysID);
            crc.update_checksum(compID);
            crc.update_checksum(msgID);
            crc.update_checksum(msgID >>> 8);
            crc.update_checksum(msgID >>> 16);
        } else {
            crc.update_checksum(payloadSize);
            crc.update_checksum(seq);
            crc.update_checksum(sysID);
            crc.update_checksum(compID);
            crc.update_checksum(msgID);
        }

        payload.resetIndex();

        for (int i = 0; i < payloadSize; i++) {
            crc.update_checksum(payload.getByte());
        }
        return crc.finish_checksum(msgID);
    }

    /**
     * Return length of actual data after trimming zeros at the end.
     * @param payload
     * @return minimum length of valid data
     */
    static int mavTrimPayload(final Uint8List payload)
    {
        int length = payload.length;
        while (length > 1 && payload[length-1] == 0) {
            length--;
        }
        return length;
    }

    /**
     * Encode this packet for transmission.
     *
     * @return Array with bytes to be transmitted
     */
    Uint8List encodePacket() {
        final int bufLen;
        final int payloadSize;

        if (isMavlink2) {
            payloadSize = mavTrimPayload(payload.getData());
            bufLen = MAVLINK2_HEADER_LEN + payloadSize + 2;
        } else {
            payloadSize = payload.size();
            bufLen = MAVLINK1_HEADER_LEN + payloadSize + 2;

        }
        ByteData buffer = ByteData(bufLen);

        int i = 0;
        if (isMavlink2) {
            buffer.setUint8(i++, MAVLINK_STX_MAVLINK2);
            buffer.setUint8(i++, payloadSize);
            buffer.setUint8(i++, incompatFlags);
            buffer.setUint8(i++, compatFlags);
            buffer.setUint8(i++, seq);
            buffer.setUint8(i++, sysID);
            buffer.setUint8(i++, compID);
            buffer.setUint8(i++, msgID & 0XFF);
            buffer.setUint8(i++, (msgID >>> 8) & 0XFF);
            buffer.setUint8(i++, (msgID >>> 16) & 0XFF);
        } else {
            buffer.setUint8(i++, MAVLINK_STX_MAVLINK1);
            buffer.setUint8(i++, payloadSize);
            buffer.setUint8(i++, seq);
            buffer.setUint8(i++, sysID);
            buffer.setUint8(i++, compID);
            buffer.setUint8(i++, msgID);
        }

        for (int j = 0; j < payloadSize; j++) {
            buffer.setUint8(i++, payload.getData().elementAt(j));
        }

        generateCRC(payloadSize);
        buffer.setUint8(i++, crc.getLSB());
        buffer.setUint8(i++, crc.getMSB());

        StringBuffer buf = StringBuffer("encode: ");
        buf.write("isMavlink2="); buf.write(isMavlink2.toString());
        buf.write("msgID="); buf.write(msgID.toString());
        _logv(buf.toString());

        return buffer.buffer.asUint8List();
    }
        ''', xml_list[0])

    f.write('''
    /**
     * Unpack the data in this packet and return a MAVLink message
     *
     * @return MAVLink message decoded from this packet
     */
    MAVLinkMessage? unpack() {
        switch (msgID) {
        ''')

    # sort msgs by id
    xml_msgs = []
    for xml in xml_list:
        for msg in xml.message:
            xml_msgs.append(msg)
    xml_msgs.sort(key=lambda msg: msg.id)

    for msg in xml_msgs:
        t.write(f, '''
        case MSG_${name}.MAVLINK_MSG_ID_${name}:
            return MSG_${name}.fromPacket(this);
        ''', msg)
    f.write('''
            default:
                return null;
        }
    }
''')

    f.write('''
}
''')
    f.close()

def copy_fixed_headers(directory, xml):
    '''copy the fixed protocol headers to the target directory'''
    import shutil
    hlist = ['lib/src/types.dart', 'lib/src/parser.dart', 'lib/src/messages/mavlink_message.dart', 'lib/mavlink.dart', 'lib/src/messages/mavlink_payload.dart',
             'lib/src/messages/mavlink_stats.dart', 'example/mavlink_example.dart', 'README.md', 'pubspec.yaml', 'test/mavlink_test.dart']
    basepath = os.path.dirname(os.path.realpath(__file__))
    srcpath = os.path.join(basepath, 'dart')
    print("Copying fixed headers")
    for h in hlist:
        src = os.path.realpath(os.path.join(srcpath, h))
        dest = os.path.realpath(os.path.join(directory, h))
        if src == dest:
            continue
        destdir = os.path.realpath(os.path.dirname(os.path.join(directory, h)))
        try:
            os.makedirs(destdir)
        except:
            pass
        shutil.copy(src, dest)

class mav_include(object):
    def __init__(self, base):
        self.base = base


def mavfmt(field, typeInfo=0):
    '''work out the struct format for a type'''
    map = {
        'float'    : ('MAVFloat', 'Float'),
        'double'   : ('MAVDouble', 'Double'),
        'char'     : ('MAVChar', 'UnsignedByte'),
        'int8_t'   : ('MAVInt8', 'Byte'),
        'uint8_t'  : ('MAVUint8', 'UnsignedByte'),
        'uint8_t_mavlink_version'  : ('MAVUint8', 'UnsignedByte'),
        'int16_t'  : ('MAVInt16', 'Short'),
        'uint16_t' : ('MAVUint16', 'UnsignedShort'),
        'int32_t'  : ('MAVInt32', 'Int'),
        'uint32_t' : ('MAVUint32', 'UnsignedInt'),
        'int64_t'  : ('MAVInt64', 'Long'),
        'uint64_t' : ('MAVUint64', 'UnsignedLong'),
    }

    return map[field.type][typeInfo]

def generate_one(basename, xml):
    '''generate headers for one XML file'''

    directory = os.path.join(basename, 'lib/src', xml.basename)

    print("Generating Dart implementation in directory %s" % directory)
    mavparse.mkdir_p(directory)

    if xml.little_endian:
        xml.mavlink_endian = "MAVLINK_LITTLE_ENDIAN"
    else:
        xml.mavlink_endian = "MAVLINK_BIG_ENDIAN"

    if xml.crc_extra:
        xml.crc_extra_define = "1"
    else:
        xml.crc_extra_define = "0"

    if xml.sort_fields:
        xml.aligned_fields_define = "1"
    else:
        xml.aligned_fields_define = "0"

    # work out the included headers
    xml.include_list = []
    for i in xml.include:
        base = i[:-4]
        xml.include_list.append(mav_include(base))

    # form message lengths array
    xml.message_lengths_array = ''
    for mlen in xml.message_lengths:
        xml.message_lengths_array += '%u, ' % mlen
    xml.message_lengths_array = xml.message_lengths_array[:-2]



    # form message info array
    xml.message_info_array = ''
    for name in xml.message_names:
        if name is not None:
            xml.message_info_array += 'MAVLINK_MESSAGE_INFO_%s, ' % name
        else:
            # Several C compilers don't accept {NULL} for
            # multi-dimensional arrays and structs
            # feed the compiler a "filled" empty message
            xml.message_info_array += '{"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, '
    xml.message_info_array = xml.message_info_array[:-2]

    # add some extra field attributes for convenience with arrays
    for m in xml.message:
        m.msg_name = m.name
        if xml.crc_extra:
            m.crc_extra_arg = ", %s" % m.crc_extra
        else:
            m.crc_extra_arg = ""
        for f in m.fields:
            if f.print_format is None:
                f.c_print_format = 'NULL'
            else:
                f.c_print_format = '"%s"' % f.print_format
            f.getChar = ''
            if f.type == 'char' and f.array_length == 0:
                f.getChar = '''
    /**
    * Sets a character from a single-character-width String
    */
    void set %s(String str) {
        if (str.length != 1) {
          throw new ArgumentError("%s Not a single character");
        }
        _%s = str.codeUnitAt(0);
    }

    /**
    * Gets the message, formatted as a string
    */
    String get %s {
        StringBuffer buf = new StringBuffer();
        buf.writeCharCode(_%s);
        return buf.toString();
    }
''' % (f.name,f.name,f.name,f.name,f.name)
            f.getText = ''
            if f.array_length != 0:
                f.array_suffix = '[] = %s(%u)' % (mavfmt(f),f.array_length)
                f.array_suffix_empty = '[]'
                f.list_prefix = 'List<'
                f.list_suffix = '>'
                f.array_prefix = '*'
                f.array_tag = '_array'
                f.array_arg = ', %u' % f.array_length
                f.array_return_arg = '%s, %u, ' % (f.name, f.array_length)
                f.array_const = 'const '
                f.decode_left = ''
                f.decode_right = 'm.%s' % (f.name)
                if f.type == 'char':
                    f.unpackField = '''
        for (int i = 0; i < %s.length; i++) {
            _%s[i] = mavPayload.get%s();
        }
                ''' % (f.name, f.name, mavfmt(f, 1) )
                    f.packField = '''
        for (int i = 0; i < %s.length; i++) {
            packet.payload.put%s(_%s[i]);
        }
                    ''' % (f.name, mavfmt(f, 1), f.name)
                else:
                    f.unpackField = '''
        for (int i = 0; i < %s.length; i++) {
            %s[i] = mavPayload.get%s();
        }
                ''' % (f.name, f.name, mavfmt(f, 1) )
                    f.packField = '''
        for (int i = 0; i < %s.length; i++) {
            packet.payload.put%s(%s[i]);
        }
                    ''' % (f.name, mavfmt(f, 1), f.name)
                f.return_type = 'uint16_t'
                f.get_arg = ', %s *%s' % (f.type, f.name)
                if f.type == 'char':

                    f.c_test_value = '"%s"' % f.test_value
                    f.getText = '''
    /**
    * Sets the buffer of this message with a string, adds the necessary padding
    */
    void set %s(String str) {
        int len = min(str.length, %d);
        for (int i=0; i<len; i++) {
            _%s[i] = str.codeUnitAt(i);
        }

        for (int i=len; i<%d; i++) {            // padding for the rest of the buffer
            _%s[i] = 0;
        }
    }

    /**
    * Gets the message, formatted as a string
    */
    String get %s {
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < %d; i++) {
            if (_%s[i] != 0)
                buf.writeCharCode(_%s[i]);
            else
                break;
        }
        return buf.toString();
    }
''' % (f.name,f.array_length,f.name,f.array_length,f.name,f.name,f.array_length,f.name,f.name)
                else:
                    test_strings = []
                    for v in f.test_value:
                        test_strings.append(str(v))
                    f.c_test_value = '{ %s }' % ', '.join(test_strings)
            else:
                f.array_suffix = ''
                f.array_suffix_empty = ''
                f.array_prefix = ''
                f.list_prefix = ''
                f.list_suffix = ''
                f.array_tag = ''
                f.array_arg = ''
                f.array_return_arg = ''
                f.array_const = ''
                f.decode_left =  '%s' % (f.name)
                f.decode_right = ''
                if f.type == 'char':
                    f.unpackField = '_%s = mavPayload.get%s();' % (f.name, mavfmt(f, 1))
                    f.packField = 'packet.payload.put%s(_%s);' % (mavfmt(f, 1),f.name)
                else:
                    f.unpackField = '%s = mavPayload.get%s();' % (f.name, mavfmt(f, 1))
                    f.packField = 'packet.payload.put%s(%s);' % (mavfmt(f, 1),f.name)
                f.get_arg = ''
                f.return_type = f.type
                if f.type == 'char':
                    f.c_test_value = "'%s'" % f.test_value
                elif f.type == 'uint64_t':
                    f.c_test_value = "%sULL" % f.test_value
                elif f.type == 'int64_t':
                    f.c_test_value = "%sLL" % f.test_value
                else:
                    f.c_test_value = f.test_value

    # cope with uint8_t_mavlink_version
    for m in xml.message:
        m.arg_fields = []
        m.array_fields = []
        m.scalar_fields = []
        for f in m.ordered_fields:
            if f.array_length != 0:
                m.array_fields.append(f)
            else:
                m.scalar_fields.append(f)
        for f in m.fields:
            if not f.omit_arg:
                m.arg_fields.append(f)
                f.putname = f.name
            else:
                f.putname = f.const_value

    for m in xml.message:
        for f in m.ordered_fields:
            # fix types to Dart
            f.origType = f.type
            f.type = mavfmt(f)
            # remove brackets in units
            f.units = removeBrackets(f.units)
            # Escape quotes in description
            f.description = cleanText(f.description);

    # separate base fields from MAVLink 2 extended fields
    for m in xml.message:
        m.base_fields = m.ordered_fields[:m.extensions_start]
        m.extended_fields = []
        if m.extensions_start is not None:
            m.extended_fields = m.ordered_fields[m.extensions_start:]

    generate_CRC(directory, xml)

    for m in xml.message:
        generate_message_h(directory, m)

    generate_platform_exports(os.path.join(basename, 'lib/src', xml.basename), xml.message)
    generate_package_exports(os.path.join(basename, 'lib'), xml.basename)

def removeBrackets(text):
    return text.replace("[","").replace("]","")

def cleanText(text):
    text = text.replace("\n"," ")
    text = text.replace("\r"," ")
    return text.replace("\"","'")

def generate(basename, xml_list):
    '''generate complete MAVLink Dart implemenation'''
    for xml in xml_list:
        generate_one(basename, xml)
        generate_enums(basename, xml)
        generate_MAVLinkMessage(basename, xml_list)
    copy_fixed_headers(basename, xml_list[0])
