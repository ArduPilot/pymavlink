#!/usr/bin/env python
'''
Parse a MAVLink protocol XML file and generate a Dart implementation

Copyright Andrew Tridgell 2011
Released under GNU GPL version 3 or later
'''
from __future__ import print_function

from builtins import object

import os
import textwrap
from . import mavparse, mavtemplate

t = mavtemplate.MAVTemplate()


def docstring(text, indent=2):
    '''take a potentially multi-line string and prefix with /// '''
    text = textwrap.dedent(text)
    lines = text.split('\n')
    newLines = []
    for line in lines:
        line = line.strip()
        if len(line) == 0:
            newLines.append(' ' * indent + '///')
        else:
            newLines.append(' ' * indent + '/// %s' % line)
    return '\n'.join(newLines)


def param_docstring(params, indent=2):
    if len(params) == 0:
        for param in params:
            param.docstring_description = ''
        return params

    newLines = ['\n' + ' ' * indent + '///\n']
    newLines.append(' ' * indent + '/// | Param Number | Description |\n')
    newLines.append(' ' * indent + '/// | ============ | =========== |\n')
    idx = 0
    for param in params:
        idx += 1
        text = textwrap.dedent(param.description)
        lines = text.split('\n')
        for line in lines:
            line = line.strip()
            if len(line) == 0:
                pass
            else:
                newLines.append(' ' * indent + '/// | %d            | %s |\n' % (idx, line))
        param.docstring_description = ''.join(newLines)
        newLines = []
    return params


def generate_enums(basename, xml):
    '''generate main header per XML file'''
    directory = os.path.join(basename, 'lib/src', xml.basename, '''enums''')

    imports = []

    mavparse.mkdir_p(directory)
    for en in xml.enum:
        f = open(os.path.join(directory, en.name.lower()+".dart"), mode='w')
        imports.append("export '%s.dart';\n" % en.name.lower())
        en.docstring_description = docstring(en.description, indent=0)
        for entry in en.entry:
            entry.docstring_description = docstring(entry.description)
            entry.param = param_docstring(entry.param)
        t.write(f, '''
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

// ignore_for_file: constant_identifier_names
// ignore_for_file: camel_case_types

${docstring_description}
class ${name} {
${{entry:${docstring_description}${{param:${docstring_description}}}\n  static const int ${name} = ${value};\n\n}}
}
''', en)
        f.close()
    f = open(os.path.join(directory, 'export.dart'), mode='w')
    f.write('''
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

library mavlink;

''')
    f.writelines(imports)
    f.close()


def generate_platform_exports(directory, messages):
    '''generate export definition'''
    f = open(os.path.join(directory, "export.dart"), mode='w')
    t.write(f, '''
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

library mavlink;

export 'crc.dart';
export 'enums/export.dart';
''')
    for m in messages:
        t.write(f, "export 'msg_%s.dart';\n" % m.name_lower)

    f.close()


def generate_package_exports(directory, basename):
    with open(os.path.join(directory, basename + '.dart'), mode='w') as f:
        t.write(f, '''
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

library mavlink;

export 'src/%s/export.dart';
''' % basename)


def generate_CRC(directory, xml):
    '''generate CRC definition and crc array per dialect'''
    xml.message_crcs_array = ''
    for msgID, crc in sorted(xml.message_crcs.items()):
        xml.message_crcs_array += '  %u: %u,\n  ' % (msgID, crc)

    f = open(os.path.join(directory, "crc.dart"), mode='w')
    t.write(f, '''
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

// ignore_for_file: constant_identifier_names
// ignore_for_file: camel_case_types

import 'package:mavlink/crc.dart';

/// CRC-16/MCRF4XX calculation for MAVlink messages. The checksum must be
/// initialized, updated with which field of the message, and then finished with
/// the message id.
class ${basename}_CRC extends DialectCRC {
  @override
  // ignore: non_constant_identifier_names
  Map<int, int> MAVLINK_MESSAGE_CRCS = {
  ${message_crcs_array}};

  /// Finish the CRC calculation of a message, by running the CRC with the
  /// Magic Byte.
  ///
  /// @param msgID The message id number
  /// @return bool True if the checksum was successfully finished. Otherwise false
  @override
  bool finish(int msgID, CRC crc) {
    if (MAVLINK_MESSAGE_CRCS.containsKey(msgID)) {
      crc.update(MAVLINK_MESSAGE_CRCS[msgID]);
      return true;
    }
    return false;
  }
}
''', xml)

    f.close()


def generate_message_h(directory, m):
    '''generate per-message header for a XML file'''
    f = open(os.path.join(directory, 'MSG_%s.dart' % m.name), mode='w')

    (path_head, path_tail) = os.path.split(directory)
    if path_tail == "":
        (path_head, path_tail) = os.path.split(path_head)
    m.docstring_description = docstring(m.description, indent=0)
    t.write(f, '''
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

// ignore_for_file: file_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types

// ignore: unused_import
import 'dart:math';

import 'crc.dart';
import 'package:mavlink/mavlink.dart';

${docstring_description}
class MSG_${name} extends MAVLinkMessage {

  static const int MAVLINK_MSG_ID_${name} = ${id};
  static const int MAVLINK_MSG_LENGTH = ${wire_length};
''', m)

    for item in m.ordered_fields:
        t.write(f, '''

  /// ${description}
  static const String ${name}_description = "${description}";
  static const String ${name}_units = "${units}";
''', item)
        if item.array_length == 0:
            if item.type == 'MAVUint64' or item.type == 'MAVInt64':
                t.write(f, '''
  ${type} _${name} = ${type}(BigInt.zero);
''', item)
            else:
                t.write(f, '''
  ${type} _${name} = ${type}(0);
''', item)
            if item.origType != "char":
                t.write(f, '''
  ${type} get ${name} => _${name};
  set ${name}(${type} setterData) {
    _${name} = setterData;
  }
''', item)
        else:
            if item.type == 'MAVUint64' or item.type == 'MAVInt64':
                t.write(f, '''
  final List<${type}> _${name} = List<${type}>.filled(${array_length}, ${type}(BigInt.from(0)), growable: false);
  static const int ${name}_max_length = ${array_length};
''', item)
            else:
                t.write(f, '''
  final List<${type}> _${name} = List<${type}>.filled(${array_length}, ${type}(0), growable: false);
  static const int ${name}_max_length = ${array_length};
''', item)
            if item.origType != "char":
                t.write(f, '''
  List<${type}> get ${name} => _${name};
  set ${name}(List<${type}> setter) {
    if (setter.length > ${array_length}) {
      var buf = StringBuffer("Provided List<${type}> for ${name} longer than allowed. Max ");
      buf.write(${array_length});
      buf.write(", provided: ");
      buf.write(setter.length);
      throw ArgumentError(buf.toString());
    }
    for (int i=0; i<setter.length; i++) {
      _${name}[i] = setter.elementAt(i);
    }
    if (setter.length < ${array_length}) {
      for (int i=setter.length; i<${array_length}; i++) {
''', item)
                if item.type == 'MAVUint64' or item.type == 'MAVInt64':
                    t.write(f, '''
        _${name}[i] = ${type}(BigInt.zero);
''', item)
                else:
                    t.write(f, '''
        _${name}[i] = ${type}(0);
''', item)
                t.write(f, '''
      }
    }
  }
''', item)
    t.write(f, '''

  /// Generates the payload for a mavlink message for a message of this type
  @override
  MAVLinkPacket pack(int packetSeq) {
    MAVLinkPacket packet = MAVLinkPacket(
      len: MAVLINK_MSG_LENGTH,
      sysID: sysID,
      compID: compID,
      msgID: MAVLINK_MSG_ID_${name},
      seq: packetSeq,
      isMavlink2: isMavlink2,
      dialectCRC: ${xml_basename}_CRC()
    );

${{base_fields:    ${packField4}\n}}

    if (isMavlink2) {${{extended_fields:${packField}}}
    }
    return packet;
  }

  /// Decode a ${name} message into this class fields
  /// @param payload The message to decode
  @override
  void unpack(MAVLinkPayload mavPayload) {
    mavPayload.resetIndex();

    ${{base_fields:${unpackField4}
    }}
    if (isMavlink2) {${{extended_fields: ${unpackField}}}
    }
  }

  // Constructor for a new message, just initializes the msgID
  MSG_${name}({required super.compID, required super.sysID, super.isMavlink2 = false}): super(msgID: MAVLINK_MSG_ID_${name}) {
    if (MAVLINK_MSG_ID_${name} > 255) {
      throw ArgumentError.value(MAVLINK_MSG_ID_${name}, "MAVLINK_MSG_ID_${name}", "MSG_${name} is not a valid packet for MAVLink1");
    }
  }

  MSG_${name}.MAVLink2({required super.compID, required super.sysID}): super(msgID: MAVLINK_MSG_ID_${name}, isMavlink2: true);
''', m)
    t.write(f, '''

  /// Constructor for a new message, initializes the message with the payload
  /// from a mavlink packet
  MSG_${name}.fromPacket(MAVLinkPacket mavLinkPacket): super(compID: mavLinkPacket.compID, sysID: mavLinkPacket.sysID, msgID: MAVLINK_MSG_ID_${name}, isMavlink2: mavLinkPacket.isMavlink2) {
    unpack(mavLinkPacket.payload);
  }
${{ordered_fields:${getChar}}}${{ordered_fields:${getText}}}

  /// Returns a string with the MSG name and data
  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return "MAVLINK_MSG_ID_${name} - sysID:"+sysID.toString()+" compID:"+compID.toString()+${{ordered_fields:" ${name}:"+${name}.toString()+}}"";
  }

  /// Returns a human-readable string of the name of the message
  @override
  String getMessageName() {
    return "MAVLINK_MSG_ID_${name}";
  }
}
''', m)
    f.close()


def generate_MAVLinkMessage(directory, xml_list):
    f = open(os.path.join(directory, 'lib/src', "mavlink_packet.dart"), mode='w')

    imports = []

    for xml in xml_list:
        if xml.basename not in ['minimal', 'standard']:
            importString = "import 'package:mavlink/{}.dart';".format(xml.basename)
            imports.append(importString)

    xml_list[0].importString = '\n'.join(imports)

    t.write(f, '''
/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * Dart mavlink generator tool. It should not be modified by hand.
 */

// ignore_for_file: constant_identifier_names

import 'dart:math';
import 'dart:typed_data';
import 'package:crypto/crypto.dart';

import 'package:mavlink/mavlink.dart';
import 'package:mavlink/crc.dart';
${importString}

abstract class MAVLinkIncompatFlags {
  static const int SIGNED = 1;
}

class MAVPacketSignature {
  int timestamp = 0;
  int linkID = 0;
  int signature = 0;

  Uint8List _secretKey = Uint8List(32);
  set secretKey(Uint8List key) {
    if (key.length != 32) {
      throw ArgumentError.value(key, 'key', 'Secret key must be 32 bytes long');
    }
    _secretKey = key;
  }

  static int epoch = DateTime(2015, 1, 1, 0, 0, 0, 0, 0).microsecondsSinceEpoch ~/ 10;
  final MAVLinkPacket _packet;

  bool isValid() {
    return !(timestamp.bitLength > 48) &&
        !(linkID.bitLength > 8) &&
        !(signature.bitLength > 48) &&
        signature == _generate();
  }

  static Uint8List generateKey() {
    return Uint8List.fromList(List.generate(32, (index) => Random().nextInt(256)));
  }

  int _generate() {
    // Take the first 48 bits of the sha256 hash of (secret_key + _packet.payload.buffer.asUint8List() + CRC + linkID + timestamp)
    var data = <int>[];
    data.addAll(_secretKey);
    var payloadSize = MAVLinkPacket.mavTrimPayload(_packet.payload.getData());
    for (var i = 0; i < payloadSize; i++) {
      data.add(_packet.payload.getData()[i]);
    }
    _packet.generateCRC(payloadSize);
    data.add(_packet.crc.getMSB());
    data.add(_packet.crc.getLSB());
    data.add(linkID);
    data.addAll([timestamp & 0xFF, (timestamp >>> 8) & 0xFF, (timestamp >>> 8*2) & 0xFF, (timestamp >>> 8*3) & 0xFF, (timestamp >>> 8*4) & 0xFF, (timestamp >>> 8*5) & 0xFF]);

    var sha = sha256.convert(data);
    return sha.bytes[0] | (sha.bytes[1] << 8) | (sha.bytes[2] << 8*2) | (sha.bytes[3] << 8*3) | (sha.bytes[4] << 8*4) | (sha.bytes[5] << 8*5);
  }

  MAVPacketSignature(MAVLinkPacket packet): _packet = packet;
  MAVPacketSignature.builder(MAVLinkPacket packet, Uint8List key, {required this.linkID}): _packet = packet {
    secretKey = key;
    timestamp = DateTime.now().microsecondsSinceEpoch ~/ 10 - MAVPacketSignature.epoch;
    signature = _generate();
  }
  MAVPacketSignature.from(MAVLinkPacket packet, Uint8List key, {required this.timestamp, required this.linkID, required this.signature}): _packet = packet {
    secretKey = key;
  }
}

/// Common interface for all MAVLink Messages
/// Packet Anatomy
/// This is the anatomy of one packet. It is inspired by the CAN and SAE AS-4 standards.
///
/// MAVLink 1 Packet Format
///
/// Byte Index  Content              Value       Explanation
/// 0            Packet start sign  v1.0: 0xFE   Indicates the start of a new packet.  (v0.9: 0x55; v1.0: 0xFE; v2.0 0xFD)
/// 1            Payload length      0 - 255     Indicates length of the following payload.
/// 2            Packet sequence     0 - 255     Each component counts up its send sequence. Allows to detect packet loss
/// 3            System ID           1 - 255     ID of the SENDING system. Allows to differentiate different MAVs on the same network.
/// 4            Component ID        0 - 255     ID of the SENDING component. Allows to differentiate different components of the same system, e.g. the IMU and the autopilot.
/// 5            Message ID          0 - 255     ID of the message - the id defines what the payload means and how it should be correctly decoded.
/// 6 to (n+6)   Payload             0 - 255     Data of the message, depends on the message id.
/// (n+7)to(n+8) Checksum (low byte, high byte)  CRC16/MCRF4XX hash, excluding packet start sign, so bytes 1..(n+6) Note: The checksum also includes MAVLINK_CRC_EXTRA (Number computed from message fields. Protects the packet from decoding a different version of the same packet but with different variables).
///
/// The checksum is the CRC16/MCRF4XX. Please see the MAVLink source code for a documented C-implementation of it. LINK TO CHECKSUM
/// The minimum packet length is 8 bytes for acknowledgement packets without payload
/// The maximum packet length is 263 bytes for full payload
///
///
/// MAVLink 2 Packet Format
///
/// Byte Index     Content             Value              Explanation
/// 0              Packet start sign  v2.0: 0xFD          Indicates the start of a new packet.  (v0.9: 0x55; v1.0: 0xFE; v2.0 0xFD)
/// 1              Payload length      0 - 255            Indicates length of the following payload.
/// 2              Incompatible Flags  0 - 255            Flags that must be understood
/// 3              Compatible Flags    0 - 255            Flags that can be ignored if not understood
/// 4              Packet sequence     0 - 255            Each component counts up its send sequence. Allows to detect packet loss
/// 5              System ID           1 - 255            ID of the SENDING system. Allows to differentiate different MAVs on the same network.
/// 6              Component ID        0 - 255            ID of the SENDING component. Allows to differentiate different components of the same system, e.g. the IMU and the autopilot.
/// 7 to 9         Message ID          0 - 16777216       ID of the message - the id defines what the payload means and how it should be correctly decoded.
/// 10             Target System ID    1 - 255            (OPTIONAL) ID of the TARGET system. Only used for point-to-point mode
/// 11             Target Component ID 0 - 255            (OPTIONAL) ID of the TARGET component. Only used for point-to-point mode
/// 12 to (n+12)   Payload             0 - 255            Data of the message, depends on the message id.
/// (n+13)to(n+14) Checksum (low byte, high byte)         CRC16/MCRF4XX hash, excluding packet start sign, so bytes 1..(n+6) Note: The checksum also includes MAVLINK_CRC_EXTRA (Number computed from message fields. Protects the packet from decoding a different version of the same packet but with different variables).
/// (n+15)to(n+27) Signature (typeid, timestamp, sha256)  (OPTIONAL) Signature which allows ensuring that the link is tamper-proof; 13 bytes containing typeid (1 byte), timestamp (6 bytes), and last 6 bytes of SHA256 hash
///
/// The signature is a combination of a typeid, timestamp, and SHA256 hash.
/// OPTIONAL fields mean that, if they are not used, they do not exist in the MAVLink frame at all. Typically target sysID and target compID are not used, and signature is only used if signing is set up between both ends.
///
/// @see [mavlink.io](https://mavlink.io) for more documentation on the MAVLink protocol
class MAVLinkPacket {
    static const int MAVLINK_STX_MAVLINK1 = 0xFE; // 254
    static const int MAVLINK_STX_MAVLINK2 = 0xFD; // 253
    static const int MAVLINK1_HEADER_LEN = 6;
    static const int MAVLINK2_HEADER_LEN = 10;
    static const int MAVLINK1_NONPAYLOAD_LEN = MAVLINK1_HEADER_LEN + 2;
    static const int MAVLINK2_NONPAYLOAD_LEN = MAVLINK2_HEADER_LEN + 2;
    static const int MAVLINK2_SIGNATURE_LEN = 13;

    static const bool _debug = false;

    static void _logv(String str) {
        StringBuffer buf = StringBuffer("MAVLinkPacket: ");
        buf.write(str);
        if(_debug) print(buf.toString());
    }

    /// Payload length
    int len;

    /// Message sequence
    int seq;

    // ID of the SENDING system. Allows to differentiate different MAVs on the
    // same network.
    int sysID;

    /// ID of the SENDING component. Allows to differentiate different components
    /// of the same system, e.g. the IMU and the autopilot.
    int compID;

    /// ID of the message - the id defines what the payload means and how it
    /// should be correctly decoded.
    int msgID;

    /// Data of the message, depends on the message id.
    MAVLinkPayload payload = MAVLinkPayload();

    // CRC-16/MCRF4XX hash, excluding packet start sign, so bytes 1..(n+HEADER-LENGTH)
    //
    // Note: The checksum also includes MAVLINK_CRC_EXTRA (Number computed from
    // message fields. Protects the packet from decoding a different version of
    // the same packet but with different variables).
    CRC crc = CRC();
    DialectCRC dialectCRC = all_CRC();

    // MAVLink 2.0 fields

    /// Flag to indicate which MAVLink version this packet is
    bool isMavlink2;

    /// Flags that must be understood
    late int _incompatFlags;
    int get incompatFlags => _incompatFlags;
    set incompatFlags(int flags) {
        _incompatFlags = flags;
        if (isSigned) {
          signature = MAVPacketSignature(this);
        }
    }

    /// Flags that can be ignored if not understood
    int compatFlags;

    bool get isSigned => isMavlink2 && (_incompatFlags & MAVLinkIncompatFlags.SIGNED) != 0;

    MAVPacketSignature? signature;

    MAVLinkPacket({required this.len, required this.sysID, required this.compID, required this.msgID, required this.seq, incompatFlags = 0, this.compatFlags = 0, this.isMavlink2 = false, dialectCRC}) {
      if (dialectCRC != null) {
        this.dialectCRC = dialectCRC;
      }
      _incompatFlags = incompatFlags;
      if (isSigned) {
        signature = MAVPacketSignature(this);
      }
    }

    /// Check if the size of the Payload is equal to the "len" byte
    bool payloadIsFilled() {
        return payload.size >= len;
    }

    /// Update CRC for this packet.
    ///
    /// @return bool True if the CRC was successfully updated. Otherwise false
    bool generateCRC(final int payloadSize) {
        crc.start();

        if (isMavlink2) {
            crc.update(payloadSize);
            crc.update(incompatFlags);
            crc.update(compatFlags);
            crc.update(seq);
            crc.update(sysID);
            crc.update(compID);
            crc.update(msgID);
            crc.update(msgID >>> 8);
            crc.update(msgID >>> 16);
        } else {
            crc.update(payloadSize);
            crc.update(seq);
            crc.update(sysID);
            crc.update(compID);
            crc.update(msgID);
        }

        payload.resetIndex();

        for (int i = 0; i < payloadSize; i++) {
            crc.update(payload.getByte().value);
        }
        return dialectCRC.finish(msgID, crc);
    }

    /// Return length of actual data after trimming zeros at the end.
    ///
    /// @param payload
    /// @return minimum length of valid data
    static int mavTrimPayload(final Uint8List payload)
    {
        int length = payload.length;
        while (length > 1 && payload[length-1] == 0) {
            length--;
        }
        return length;
    }

    /// Encode this packet for transmission.
    ///
    /// @return Array with bytes to be transmitted
    Uint8List encodePacket() {
        final int bufLen;
        final int payloadSize;

        if (isMavlink2) {
            payloadSize = mavTrimPayload(payload.getData());
            bufLen = MAVLINK2_HEADER_LEN + payloadSize + 2 + (isSigned ? MAVLINK2_SIGNATURE_LEN : 0);
        } else {
            payloadSize = payload.size;
            bufLen = MAVLINK1_HEADER_LEN + payloadSize + 2;

        }
        ByteData buffer = ByteData(bufLen);

        int i = 0;
        if (isMavlink2) {
            buffer.setUint8(i++, MAVLINK_STX_MAVLINK2);
            buffer.setUint8(i++, payloadSize);
            buffer.setUint8(i++, incompatFlags);
            buffer.setUint8(i++, compatFlags);
            buffer.setUint8(i++, seq);
            buffer.setUint8(i++, sysID);
            buffer.setUint8(i++, compID);
            buffer.setUint8(i++, msgID & 0XFF);
            buffer.setUint8(i++, (msgID >>> 8) & 0XFF);
            buffer.setUint8(i++, (msgID >>> 16) & 0XFF);
        } else {
            buffer.setUint8(i++, MAVLINK_STX_MAVLINK1);
            buffer.setUint8(i++, payloadSize);
            buffer.setUint8(i++, seq);
            buffer.setUint8(i++, sysID);
            buffer.setUint8(i++, compID);
            buffer.setUint8(i++, msgID);
        }

        for (int j = 0; j < payloadSize; j++) {
            buffer.setUint8(i++, payload.getData().elementAt(j));
        }

        generateCRC(payloadSize);
        buffer.setUint8(i++, crc.getLSB());
        buffer.setUint8(i++, crc.getMSB());

        if (isSigned) {
          buffer.setUint8(i++, signature!.linkID);

          var strSub = signature!.timestamp.toRadixString(16).padLeft(12, '0');
          for (int j = 12; j > 1; j-=2) {
            buffer.setUint8(i++, int.parse(strSub.substring(j-2, j), radix: 16) & 0XFF);
          }

          strSub = signature!.signature.toRadixString(16).padLeft(12, '0');
          for (int j = 12; j > 1; j-=2) {
            buffer.setUint8(i++, int.parse(strSub.substring(j-2, j), radix: 16) & 0XFF);
          }
        }

        StringBuffer buf = StringBuffer("encode: ");
        buf.write("isMavlink2="); buf.write(isMavlink2.toString());
        buf.write("msgID="); buf.write(msgID.toString());
        _logv(buf.toString());

        return buffer.buffer.asUint8List();
    }
        ''', xml_list[0])

    f.write('''
    /// Unpack the data in this packet and return a MAVLink message
    ///
    /// @return MAVLink message decoded from this packet
    MAVLinkMessage? unpack() {
        switch (msgID) {
        ''')

    # sort msgs by id
    xml_msgs = []

    xml_ids = []
    idConflict = False
    idConflicts = []
    for xml in xml_list:
        for msg in xml.message:
            xml_msgs.append(msg)
            if msg.id in xml_ids:
                idConflict = True
                idConflicts.append(msg.id)
            xml_ids.append(msg.id)
    if idConflict:
        print("WARNING: Message IDs are not unique: %s" % idConflicts)
    xml_msgs.sort(key=lambda msg: msg.id)

    for msg in xml_msgs:
        t.write(f, '''
        case MSG_${name}.MAVLINK_MSG_ID_${name}:
            return MSG_${name}.fromPacket(this);
        ''', msg)
    f.write('''
            default:
                return null;
        }
    }
''')

    f.write('''
}
''')
    f.close()


def copy_fixed_headers(directory, xml):
    '''copy the fixed protocol headers to the target directory'''
    import shutil
    hlist = ['lib/src/types.dart', 'lib/src/parser.dart', 'lib/src/messages/mavlink_message.dart',
             'lib/mavlink.dart', 'lib/src/messages/mavlink_payload.dart',
             'lib/src/messages/mavlink_stats.dart', 'example/mavlink_example.dart', 'README.md',
             'pubspec.yaml', 'test/mavlink_test.dart', 'Makefile', 'lib/crc.dart', 'lib/src/crc.dart',
             'analysis_options.yaml']
    basepath = os.path.dirname(os.path.realpath(__file__))
    srcpath = os.path.join(basepath, 'dart')
    print("Copying fixed headers")
    for h in hlist:
        src = os.path.realpath(os.path.join(srcpath, h))
        dest = os.path.realpath(os.path.join(directory, h))
        if src == dest:
            continue
        destdir = os.path.realpath(os.path.dirname(os.path.join(directory, h)))
        try:
            os.makedirs(destdir)
        except Exception:
            pass
        shutil.copy(src, dest)


class mav_include(object):
    def __init__(self, base):
        self.base = base


def mavfmt(field, typeInfo=0):
    '''work out the struct format for a type'''
    map = {
        'float': ('MAVFloat', 'Float'),
        'double': ('MAVDouble', 'Double'),
        'char': ('MAVChar', 'Char'),
        'int8_t': ('MAVInt8', 'Byte'),
        'uint8_t': ('MAVUint8', 'UnsignedByte'),
        'uint8_t_mavlink_version': ('MAVUint8', 'UnsignedByte'),
        'int16_t': ('MAVInt16', 'Short'),
        'uint16_t': ('MAVUint16', 'UnsignedShort'),
        'int32_t': ('MAVInt32', 'Int'),
        'uint32_t': ('MAVUint32', 'UnsignedInt'),
        'int64_t': ('MAVInt64', 'Long'),
        'uint64_t': ('MAVUint64', 'UnsignedLong'),
    }

    return map[field.type][typeInfo]


def generate_one(basename, xml):
    '''generate headers for one XML file'''

    directory = os.path.join(basename, 'lib/src', xml.basename)

    print("Generating Dart implementation in directory %s" % directory)
    mavparse.mkdir_p(directory)

    if xml.little_endian:
        xml.mavlink_endian = "MAVLINK_LITTLE_ENDIAN"
    else:
        xml.mavlink_endian = "MAVLINK_BIG_ENDIAN"

    if xml.crc_extra:
        xml.crc_extra_define = "1"
    else:
        xml.crc_extra_define = "0"

    if xml.sort_fields:
        xml.aligned_fields_define = "1"
    else:
        xml.aligned_fields_define = "0"

    # work out the included headers
    xml.include_list = []
    for i in xml.include:
        base = i[:-4]
        xml.include_list.append(mav_include(base))

    # form message lengths array
    xml.message_lengths_array = ''
    for mlen in xml.message_lengths:
        xml.message_lengths_array += '%u, ' % mlen
    xml.message_lengths_array = xml.message_lengths_array[:-2]

    # form message info array
    xml.message_info_array = ''
    for name in xml.message_names:
        if name is not None:
            xml.message_info_array += 'MAVLINK_MESSAGE_INFO_%s, ' % name
        else:
            # Several C compilers don't accept {NULL} for
            # multi-dimensional arrays and structs
            # feed the compiler a "filled" empty message
            xml.message_info_array += '{"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, '
    xml.message_info_array = xml.message_info_array[:-2]

    # add some extra field attributes for convenience with arrays
    for m in xml.message:
        m.msg_name = m.name
        if xml.crc_extra:
            m.crc_extra_arg = ", %s" % m.crc_extra
        else:
            m.crc_extra_arg = ""
        for f in m.fields:
            if f.print_format is None:
                f.c_print_format = 'NULL'
            else:
                f.c_print_format = '"%s"' % f.print_format
            f.getChar = ''
            if f.type == 'char' and f.array_length == 0:
                f.getChar = '''
  /// Sets a character from a single-character-width String
  set %s(String str) {
    _%s = MAVChar.fromString(str);
  }

  /// Gets the message, formatted as a string
  String get %s {
    StringBuffer buf = StringBuffer();
    buf.writeCharCode(_%s.value);
    return buf.toString();
  }
''' % (f.name, f.name, f.name, f.name)
            f.getText = ''
            if f.array_length != 0:
                f.array_suffix = '[] = %s(%u)' % (mavfmt(f), f.array_length)
                f.array_suffix_empty = '[]'
                f.list_prefix = 'List<'
                f.list_suffix = '>'
                f.array_prefix = '*'
                f.array_tag = '_array'
                f.array_arg = ', %u' % f.array_length
                f.array_return_arg = '%s, %u, ' % (f.name, f.array_length)
                f.array_const = 'const '
                f.decode_left = ''
                f.decode_right = 'm.%s' % (f.name)
                if f.type == 'char':
                    f.unpackField = '''
      for (int i = 0; i < %s.length; i++) {
        _%s[i] = mavPayload.get%s();
      }
''' % (f.name, f.name, mavfmt(f, 1))
                    f.packField = '''
      for (int i = 0; i < %s.length; i++) {
        packet.payload.put%s(_%s[i]);
      }
''' % (f.name, mavfmt(f, 1), f.name)
                    f.unpackField4 = '''
    for (int i = 0; i < %s.length; i++) {
      _%s[i] = mavPayload.get%s();
    }
''' % (f.name, f.name, mavfmt(f, 1))
                    f.packField4 = '''
    for (int i = 0; i < %s.length; i++) {
      packet.payload.put%s(_%s[i]);
    }
''' % (f.name, mavfmt(f, 1), f.name)
                else:
                    f.unpackField = '''
      for (int i = 0; i < %s.length; i++) {
        %s[i] = mavPayload.get%s();
      }
''' % (f.name, f.name, mavfmt(f, 1))
                    f.unpackField4 = '''
    for (int i = 0; i < %s.length; i++) {
      %s[i] = mavPayload.get%s();
    }
''' % (f.name, f.name, mavfmt(f, 1))
                    f.packField = '''
      for (int i = 0; i < %s.length; i++) {
        packet.payload.put%s(%s[i]);
      }
''' % (f.name, mavfmt(f, 1), f.name)
                    f.packField4 = '''
    for (int i = 0; i < %s.length; i++) {
      packet.payload.put%s(%s[i]);
    }
''' % (f.name, mavfmt(f, 1), f.name)
                f.return_type = 'uint16_t'
                f.get_arg = ', %s *%s' % (f.type, f.name)
                if f.type == 'char':

                    f.c_test_value = '"%s"' % f.test_value
                    f.getText = '''

  /// Sets the buffer of this message with a string, adds the necessary padding
  set %s(String str) {
    int len = min(str.length, %d);
    for (int i=0; i<len; i++) {
      _%s[i] = MAVChar(str.codeUnitAt(i));
    }

    // padding for the rest of the buffer
    for (int i=len; i<%d; i++) {
      _%s[i] = MAVChar(0);
    }
  }

  /// Gets the message, formatted as a string
  String get %s {
    StringBuffer buf = StringBuffer();
    for (int i = 0; i < %d; i++) {
      if (_%s[i].value != 0) {
        buf.writeCharCode(_%s[i].value);
      } else {
        break;
      }
    }
    return buf.toString();
  }
''' % (f.name, f.array_length, f.name, f.array_length, f.name, f.name, f.array_length, f.name, f.name)
                else:
                    test_strings = []
                    for v in f.test_value:
                        test_strings.append(str(v))
                    f.c_test_value = '{ %s }' % ', '.join(test_strings)
            else:
                f.array_suffix = ''
                f.array_suffix_empty = ''
                f.array_prefix = ''
                f.list_prefix = ''
                f.list_suffix = ''
                f.array_tag = ''
                f.array_arg = ''
                f.array_return_arg = ''
                f.array_const = ''
                f.decode_left = '%s' % (f.name)
                f.decode_right = ''
                if f.type == 'char':
                    f.unpackField4 = '_%s = mavPayload.get%s();' % (f.name, mavfmt(f, 1))
                    f.unpackField = '_%s = mavPayload.get%s();' % (f.name, mavfmt(f, 1))
                    f.packField = 'packet.payload.put%s(_%s);' % (mavfmt(f, 1), f.name)
                    f.packField4 = 'packet.payload.put%s(_%s);' % (mavfmt(f, 1), f.name)
                else:
                    f.unpackField = '%s = mavPayload.get%s();' % (f.name, mavfmt(f, 1))
                    f.unpackField4 = '%s = mavPayload.get%s();' % (f.name, mavfmt(f, 1))
                    f.packField = 'packet.payload.put%s(%s);' % (mavfmt(f, 1), f.name)
                    f.packField4 = 'packet.payload.put%s(%s);' % (mavfmt(f, 1), f.name)
                f.get_arg = ''
                f.return_type = f.type
                if f.type == 'char':
                    f.c_test_value = "'%s'" % f.test_value
                elif f.type == 'uint64_t':
                    f.c_test_value = "%sULL" % f.test_value
                elif f.type == 'int64_t':
                    f.c_test_value = "%sLL" % f.test_value
                else:
                    f.c_test_value = f.test_value

    # cope with uint8_t_mavlink_version
    for m in xml.message:
        m.arg_fields = []
        m.array_fields = []
        m.scalar_fields = []
        for f in m.ordered_fields:
            if f.array_length != 0:
                m.array_fields.append(f)
            else:
                m.scalar_fields.append(f)
        for f in m.fields:
            if not f.omit_arg:
                m.arg_fields.append(f)
                f.putname = f.name
            else:
                f.putname = f.const_value

    for m in xml.message:
        for f in m.ordered_fields:
            # fix types to Dart
            f.origType = f.type
            f.type = mavfmt(f)
            # remove brackets in units
            f.units = removeBrackets(f.units)
            # Escape quotes in description
            f.description = cleanText(f.description)

    # separate base fields from MAVLink 2 extended fields
    for m in xml.message:
        m.base_fields = m.ordered_fields[:m.extensions_start]
        m.extended_fields = []
        if m.extensions_start is not None:
            m.extended_fields = m.ordered_fields[m.extensions_start:]

    generate_CRC(directory, xml)

    for m in xml.message:
        m.xml_basename = xml.basename
        generate_message_h(directory, m)

    generate_platform_exports(os.path.join(basename, 'lib/src', xml.basename), xml.message)
    generate_package_exports(os.path.join(basename, 'lib'), xml.basename)


def removeBrackets(text):
    return text.replace("[", "").replace("]", "")


def cleanText(text):
    text = text.replace("\n", " ")
    text = text.replace("\r", " ")
    return text.replace("\"", "'")


def generate(basename, xml_list):
    '''generate complete MAVLink Dart implemenation'''
    for xml in xml_list:
        generate_one(basename, xml)
        generate_enums(basename, xml)
        generate_MAVLinkMessage(basename, xml_list)
    copy_fixed_headers(basename, xml_list[0])
