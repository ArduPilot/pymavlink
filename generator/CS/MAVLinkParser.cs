/// <Remark>
/// AUTO-GENERATED FILE.  DO NOT MODIFY.
/// 
/// This class was automatically generated by the
/// C# mavlink generator tool. It should not be modified by hand.
/// </Remark>
using System;
using System.Collections.Generic;

namespace MavLinkProtocol
{
    /// <summary>
    ///     MAVLinkParser class for parsing received bytes.
    /// </summary>
    /// <remarks>
    ///     User of this class can listen to packet received events containing fully parsed and validated packets
    ///     while feeding this class with bytes off the wire as they arrive.
    ///     <para>
    ///     NOTE: this class keeps track of "leftover" bytes of previously parsed byte arrays, so it should be 
    ///     handled synchronously!
    ///     </para>
    /// </remarks>
    public class MAVLinkParser
    {
        /// <summary>
        ///     Internal array of previously unparsed bytes.
        /// </summary>
        private List<byte> _leftovers;

        /// <summary>
        ///     Total number of packets successfully received so far
        /// </summary>
        public uint PacketsReceived { get; private set; }

        /// <summary>
        ///     Total number of packets which have been rejected due to a failed crc
        /// </summary>
        public uint BadCrcPacketsReceived { get; private set; }

        /// <summary>
        ///     Event raised when a message is decoded successfully
        /// </summary>
        public event EventHandler<MAVLinkPacket> PacketReceived;

        /// <summary>
        ///     Create a new MavlinkParser Object
        /// </summary>
        public MAVLinkParser()
        {
            _leftovers = new List<byte>();
        }

        /// <summary>
        ///     Will add all newly received bytes to possible "leftovers" from last parse action and will try to 
        ///     parse all MavLink Packets in this byte array.
        ///     <para>Each successfully parsed packet is delegated using the <c><see cref="PacketReceived"/></c> event.</para>
        ///     <para>Method will return once the array does not contain any valid packet anymore.</para>
        /// </summary>
        /// <remarks>
        ///     Make sure this method is called from a synchronized thread, since it is maintaining a byte array of 
        ///     possible "leftover" bytes for a previous parse action!
        /// </remarks>
        /// <param name="newlyReceived">Byte array containing newly received bytes</param>
        public void ParseBytes(byte[] newlyReceived)
        {
            // create byte array/list for previously unparsed and newly received bytes.
            var bytesToProcess = new List<byte>(newlyReceived.Length + _leftovers.Count);

            // add previously unparsed bytes at the beginning of the list
            bytesToProcess.InsertRange(0, _leftovers);
            // newly received bytes at the end
            bytesToProcess.InsertRange(_leftovers.Count, newlyReceived);

            // Clear leftovers since they are now inside bytes to process.
            _leftovers.Clear();

            // continue until something it can't find anything.
            while (true)
            {
                // Try to find the Protocol Marker in the bytes to process. It will return -1 if not found.
                int index = bytesToProcess.FindIndex(b => b == MAVLinkPacket.MAVLINK_V1_STX || b == MAVLinkV2Packet.MAVLINK_V2_STX);

                // Protocol magic Marker (start byte) not found, don't save bytes to process, 
                // since there is no beginning of a message yet, return.
                if (index < 0) return;

                // remove bytes in front of Protocol Marker since they are garbage
                bytesToProcess.RemoveRange(0, index);

                // Determine Protocol verion.
                bool isVersion2 = (bytesToProcess[0] == MAVLinkV2Packet.MAVLINK_V2_STX);

                // Determine header size based over protocol version.
                int headerSize = isVersion2 ? MAVLinkV2Packet.MAVLINK_V2_HEADER_LEN : MAVLinkPacket.MAVLINK_V1_HEADER_LEN;

                // if we don't have the minimum number of bytes, put them in leftover and return
                if (bytesToProcess.Count < headerSize + MAVLinkPacket.MAVLINK_CRC_LEN)
                {
                    _leftovers = new List<byte>(bytesToProcess);
                    return;
                }

                // Calculate expected packet size (header + payload + 'overhead' bytes (crc and optional signature)
                // Note byte[2] is not valid for V1 but is also not being processed for V1.
                int possibleMessageLength = GetExpectedPacketLength(isVersion2, bytesToProcess[1], bytesToProcess[2]);

                // If we don't have enough bytes for this packet to satisfy the expected packet length,
                // put them in leftover and return
                if (bytesToProcess.Count < possibleMessageLength)
                {
                    _leftovers = new List<byte>(bytesToProcess);
                    return;
                }

                // Create a byte array and store the possible message in it.
                byte[] possibleMAVLinkPacket = new byte[possibleMessageLength];
                bytesToProcess.CopyTo(0, possibleMAVLinkPacket, 0, possibleMessageLength);

                // Create a Mavlink Packet.
                MAVLinkPacket packet;
                if (!isVersion2)
                    packet = new MAVLinkPacket(possibleMAVLinkPacket);
                else
                    packet = new MAVLinkV2Packet(possibleMAVLinkPacket);

                // If IsPacketValid is not true, because the CRC is invalid or SystemID or ComponentID are invalid.
                if (!packet.IsPacketValid)
                {
                    // Only remove Protocol Marker byte. It could be that we didn't catch the start marker but a leftover 
                    // databyte. Next parse action wil resolve that by finding next possible start marker.
                    bytesToProcess.RemoveAt(0);

                    BadCrcPacketsReceived++;
                    continue;
                }

                // If IsPacketValid is true, the package is correctly received. 
                // Invoke event with found packet.
                PacketReceived?.Invoke(this, packet);
                PacketsReceived++;

                // Remove packet bytes from queue.
                bytesToProcess.RemoveRange(0, possibleMessageLength);
            }
        }

        /// <summary>
        ///     Method to calculate expected number of bytes required for the complete MAVLink packet.
        ///     This includes, the header, payload, CRC and optional signature block.
        /// </summary>
        /// <param name="isVersion2">Boolean flag (based on magic byte) if packet is marked as MAVLink V2</param>
        /// <param name="payloadLength">Payload length based on provided Length byte</param>
        /// <param name="incompFlags">Incompatibilty flags to determine if a signature is expected.</param>
        /// <returns></returns>
        private static int GetExpectedPacketLength(bool isVersion2, int payloadLength, byte incompFlags)
        {
            int packetLength = payloadLength + MAVLinkPacket.MAVLINK_CRC_LEN;
            if (isVersion2)
            {
                packetLength += MAVLinkV2Packet.MAVLINK_V2_HEADER_LEN;
                if ((incompFlags & MAVLinkV2Packet.MAVLINK_ICOMP_FLAG_SIGNED) > 0)
                    packetLength += MAVLinkV2Packet.MAVLINK_SIGNATURE_BLOCK_LEN;
            }
            else
            {
                packetLength += MAVLinkPacket.MAVLINK_V1_HEADER_LEN;
            }
            return packetLength;
        }
    }
}