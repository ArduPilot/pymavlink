/// <Remark>
/// AUTO-GENERATED FILE.  DO NOT MODIFY.
/// 
/// This class was automatically generated by the
/// C# mavlink generator tool. It should not be modified by hand.
/// </Remark>
using System;

namespace MavLinkProtocol
{
    /// <summary>
    ///     Represents a Mavlink V2 Packet message - both the message object itself
    ///     and the identified sending party
    /// </summary>
    public class MAVLinkV2Packet : MAVLinkPacket
    {
        // MAVLink Version 2 constant values
        public const byte MAVLINK_V2_STX = 0xFD;
        public const byte MAVLINK_V2_HEADER_LEN = 10;

        public const byte MAVLINK_ICOMP_FLAG_SIGNED = 0x01;
        public const byte MAVLINK_SIGNATURE_BLOCK_LEN = 13;

        /// <inheritdoc/>
        internal override byte MAVLINK_STX => MAVLINK_V2_STX;

        #region LenghtDefinitions
        // The following (fixed) fields are overriding defined lenghtes for MAVLink V2 sections
        protected internal override int MAVLINK_HEADER_LEN => MAVLINK_V2_HEADER_LEN;
        protected internal override int MAVLINK_MSG_ID_LEN => 3;
        protected internal override int MAVLINK_NONPAYLOAD_LEN => MAVLINK_HEADER_LEN + MAVLINK_CRC_LEN;
        #endregion LenghtDefinitions

        #region PayloadByteOffsets
        // The following (fixed) fields are overriding the defined offsets of the different 
        // sections in the packet byte array for MAVLink V2.
        protected internal int MAVLINK_OFFSET_INCOMP_FLAGS => 2;
        protected internal int MAVLINK_OFFSET_COMP_FLAGS => 3;
        protected internal override int MAVLINK_OFFSET_SEQNR => 4;
        protected internal override int MAVLINK_OFFSET_SYS_ID => 5;
        protected internal override int MAVLINK_OFFSET_COMP_ID => 6;
        protected internal override int MAVLINK_OFFSET_MESG_ID => 7;
        protected internal override int MAVLINK_OFFSET_PAYLOAD => MAVLINK_HEADER_LEN;
        protected internal int MAVLINK_OFFSET_SIGNATURE => MAVLINK_OFFSET_CRC + MAVLINK_CRC_LEN;
        #endregion PayloadByteOffsets

        /// <summary>
        ///     Flag to determine if packet has been parsed (encoded/decoded) correctly.
        /// </summary>
        private readonly bool _isV2PacketCorrect = false;

        /// <summary>
        ///     Flag to indicate if this packet is MAVLink version 2
        /// </summary>
        public override bool IsMavLinkV2 => true;

        /// <summary>
        ///     Flags that must be understood for MAVLink compatibility (decoding process 
        ///     will discard packet if it does not understand one of flags).
        /// </summary>
        public byte IncompatibilityFlags => Bytes[MAVLINK_OFFSET_INCOMP_FLAGS];

        /// <summary>
        ///     Flags that can be ignored if not understood (decoding process will still 
        ///     handle packet even if it does not understand all or any of the flags).
        /// </summary>
        public byte CompatibilityFlags => Bytes[MAVLINK_OFFSET_COMP_FLAGS];

        /// <summary>
        ///     Is set to true if the CRC bytes are valid and the packet has been parsed correctly
        /// </summary>
        public override bool IsPacketValid => _isCRCValid && _isV2PacketCorrect;

        /// <summary>
        ///     Constructor to decode a byte array to a MAVLinkV2Packet and validates the packet
        ///     using the CRC.
        ///     Check <see cref="IsPacketValid"/> to see if packet is valid to use.
        /// </summary>
        /// <remarks>
        ///     An optional signature is currently not eveluated and if present will result in an invalid packet!
        /// </remarks>
        /// <param name="buff">byte array containing the encoded MAVLink packet.</param>
        internal MAVLinkV2Packet(byte[] buff) : base(buff)
        {
            if ((IncompatibilityFlags & MAVLINK_ICOMP_FLAG_SIGNED) == MAVLINK_ICOMP_FLAG_SIGNED)
            {
                // TODO: Signing is not supported yet do not continue parsing

                _isV2PacketCorrect = false;
                return;
            }
            _isV2PacketCorrect = true;
        }

        /// <summary>
        ///     Constructor to create and encode a MAVLinkV2Packet to be send.
        ///     It assumes the provided payload is a valid <see cref="MAVLinkMessage"/> payload object that is correctly filled
        ///     and will immediately serialize the packet to a byte array <seealso cref="MAVLinkPacket.Bytes"/>.
        /// </summary>
        /// <param name="payload">MAVLinkMessage type object</param>
        /// <param name="systemId">System ID of the source (this) system sending the message. NOTE: may not be 0</param>
        /// <param name="componentId">Component ID of the source (this) system sending the message. NOTE: May not be <see cref="MAV_COMPONENT.MAV_COMP_ID_ALL"/></param>
        /// <param name="sequenceNumber">Incremented sequence number of the packet.</param>
        /// <param name="incompatibilityFlags">[Optional] Flags that must be understood for MAVLink compatibility</param>
        /// <param name="compatibilityFlags">[Optional] Flags that can be ignored if not understood</param>
        /// <exception cref="ArgumentException">Thrown when SystemID, ComponentID or payload are invalid!</exception>
        public MAVLinkV2Packet(MAVLinkMessage payload, byte systemId, MAV_COMPONENT componentId, byte sequenceNumber,
                    byte incompatibilityFlags = 0, byte compatibilityFlags = 0) : base(payload, systemId, componentId, sequenceNumber)
        {
            Bytes[MAVLINK_OFFSET_INCOMP_FLAGS] = incompatibilityFlags;
            Bytes[MAVLINK_OFFSET_COMP_FLAGS] = compatibilityFlags;

            if ((incompatibilityFlags & MAVLINK_ICOMP_FLAG_SIGNED) == MAVLINK_ICOMP_FLAG_SIGNED)
            {
                // TODO: Signing is not supported yet do not continue parsing

                _isV2PacketCorrect = false;
                return;
            }
            _isV2PacketCorrect = true;
        }

        /// <summary>
        ///     Method to calculate the total packet size including, header, payload size and optional signature block.
        ///     This is required for creating a correctly sized byte array.
        /// </summary>
        /// <param name="payloadSize">Size of payload</param>
        /// <returns>Total packet size</returns>
        protected internal override int GetPacketSizeForMessage(int payloadSize)
        {
            return MAVLINK_NONPAYLOAD_LEN + payloadSize;
        }

        /// <summary>
        ///     Method to trim the payload byte array (truncation of '0' value endings).
        /// </summary>
        /// <param name="payload">Reference to payload byte array that needs truncation</param>
        /// <returns>Truncated byte array.</returns>
        protected internal override byte[] TrimPayload(ref byte[] payload)
        {
            var length = payload.Length;
            while (length > 1 && payload[length - 1] == 0)
            {
                length--;
            }
            if (length != payload.Length)
                Array.Resize(ref payload, length);
            return payload;
        }
    }
}