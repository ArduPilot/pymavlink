/// <Remark>
/// AUTO-GENERATED FILE.  DO NOT MODIFY.
/// 
/// This class was automatically generated by the
/// C# mavlink generator tool. It should not be modified by hand.
/// </Remark>
using System;
using System.Linq;

namespace MavLinkProtocol
{
    /// <summary>
    ///     Represents a Mavlink (V1) packet - both the message object itself
    ///     and the identified sending party
    /// </summary>
    public class MAVLinkPacket
    {
        // MAVLink Version 1 constant values
        public const byte MAVLINK_V1_STX = 0xFE;
        public const byte MAVLINK_V1_HEADER_LEN = 6;

        public const byte MAVLINK_CRC_LEN = 2;

        /// <summary>
        ///     Magic marker byte for this version of MavLink
        /// </summary>
        internal virtual byte MAVLINK_STX => MAVLINK_V1_STX;

        #region LenghtDefinitions
        // The following (fixed) fields are defined lenghtes for MAVLink V1 sections
        protected internal virtual int MAVLINK_HEADER_LEN => MAVLINK_V1_HEADER_LEN;
        protected internal virtual int MAVLINK_MSG_ID_LEN => 1;
        protected internal virtual int MAVLINK_NONPAYLOAD_LEN => MAVLINK_HEADER_LEN + MAVLINK_CRC_LEN;
        #endregion LenghtDefinitions

        #region PayloadByteOffsets
        // The following (fixed) fields are defined offsets for MAVLink V1 of the different 
        // sections in the packet byte array.
        internal int MAVLINK_OFFSET_STX => 0;
        internal virtual int MAVLINK_OFFSET_LEN => 1;
        protected internal virtual int MAVLINK_OFFSET_SEQNR => 2;
        protected internal virtual int MAVLINK_OFFSET_SYS_ID => 3;
        protected internal virtual int MAVLINK_OFFSET_COMP_ID => 4;
        protected internal virtual int MAVLINK_OFFSET_MESG_ID => 5;
        protected internal virtual int MAVLINK_OFFSET_PAYLOAD => MAVLINK_HEADER_LEN;
        protected internal virtual int MAVLINK_OFFSET_CRC => MAVLINK_OFFSET_PAYLOAD + PayloadSize;
        #endregion PayloadByteOffsets

        /// <summary>
        ///     Flag to indicate if this packet is MAVLink version 2
        /// </summary>
        public virtual bool IsMavLinkV2 => false;

        /// <summary>
        ///     Time of creation of this object instance
        /// </summary>
        public readonly DateTime TimeStamp;

        /// <summary>
        ///     Indicates length of the following payload section. 
        ///     This may be affected by payload truncation.
        /// </summary>
        protected internal byte PayloadSize => Bytes[MAVLINK_OFFSET_LEN];

        /// <summary>
        ///      Packet sequence. Can be used to detect packet loss. 
        ///      Sending components increments the value for each message sent.
        /// </summary>
        public byte SequenceNumber => Bytes[MAVLINK_OFFSET_SEQNR];

        /// <summary>
        ///     System ID of the SENDING system. Allows to differentiate different devices/systems 
        ///     on the same network.
        /// </summary>
        public byte SystemId => Bytes[MAVLINK_OFFSET_SYS_ID];

        /// <summary>
        ///     Component ID of the SENDING component. Allows to differentiate different components 
        ///     of the same system, e.g.the IMU and the autopilot.
        /// </summary>
        public MAV_COMPONENT ComponentId => (MAV_COMPONENT)Bytes[MAVLINK_OFFSET_COMP_ID];

        /// <summary>
        ///     ID of the message - the id defines what the payload means and how it should be correctly 
        ///     decoded.
        /// </summary>
        public readonly int MessageId;

        /// <summary>
        ///     Byte array of the payload message.
        /// </summary>
        private byte[] _payloadBytes => Bytes.Skip(MAVLINK_OFFSET_PAYLOAD).Take(PayloadSize).ToArray();
        /// <summary>
        ///     Locally buffered decoded payload. 
        /// </summary>
        private MAVLinkMessage _paload;
        /// <summary>
        ///     Decoded Mavlink message object, depends on the <see cref="MessageId"/>.
        /// </summary>
        /// <remarks>
        ///     NOTE: The Payload will be decoded on first request. To check if the Payload is of desired 
        ///     type, it is best to check the <see cref="MessageId"/>, against MSG_ID of the desired Message 
        ///     first to avoid unneccesary decoding.
        /// </remarks>
        public MAVLinkMessage Payload
        {
            get
            {
                if (_paload == null && IsPacketValid)
                {
                    // If message integrity is checked with CRC, derialize payload.
                    if (MAVLinkDeserializer.Lookup.ContainsKey(MessageId))
                        _paload = MAVLinkDeserializer.Lookup[MessageId].Unpack.Invoke(_payloadBytes, IsMavLinkV2);
                }
                return _paload;
            }
        }

        /// <summary>
        ///      CRC-16/MCRF4XX hash, excluding magic start byte and signature, so bytes 1..(n+HEADER-LENGTH)
        /// </summary>
        /// <remarks>
        ///     Note: The checksum also includes MAVLINK_CRC_EXTRA(Number computed from 
        ///     message fields.Protects the packet from decoding a different version of 
        ///     the same packet but with different variables).
        /// </remarks>
        private int _crcBytes;

        /// <summary>
        ///     Flag to indicate if the CRC validation is done and succesful
        /// </summary>
        protected readonly bool _isCRCValid = false;

        /// <summary>
        ///     Is set to true if the CRC bytes are valid for this packet.
        /// </summary>
        public virtual bool IsPacketValid => _isCRCValid;

        /// <summary>
        ///     The serialized byte array of this Packet
        /// </summary>
        public byte[] Bytes { get; }

        /// <summary>
        ///     Constructor to decode a byte array to a MAVLinkPacket and validates the packet
        ///     using the CRC.
        ///     Check <see cref="IsPacketValid"/> to see if packet is valid to use.
        /// </summary>
        /// <param name="buff">byte array containing the encoded MAVLink packet.</param>
        internal MAVLinkPacket(byte[] buff)
        {
            TimeStamp = DateTime.Now;
            Bytes = buff;

            // Broadcast systemID or ComponentID is not allowed
            if (SystemId == 0 || ComponentId == 0)
            {
                _isCRCValid = false;
                return;
            }

            // Retrieve messageID from message (can not be obtained dynamically because it 
            // can be up to 3 bytes for MavLink V2)
            for (var i = 0; i < MAVLINK_MSG_ID_LEN; i++)
            {
                MessageId += Bytes[MAVLINK_OFFSET_MESG_ID + i] << (8 * i);
            }

            // extract checksum bytes
            _crcBytes = Bytes[MAVLINK_OFFSET_CRC + 1] << 8 | Bytes[MAVLINK_OFFSET_CRC];

            // Note: CRC needs to exclude the magic (version) byte at the beginning (start offset +1 and headersize -1)
            var crc = MAVLinkCrc.Calculate(buff, 1, MAVLINK_OFFSET_CRC - 1);

            // Find packet info for this version and dialect to determin possible extentions.
            if (!MAVLinkDeserializer.Lookup.TryGetValue(MessageId, out MAVLinkDeserializer packetInfo))
            {
                // This was an unknown message, so not valid can be ignored
                _isCRCValid = false;
                return;
            }

            // Add CRC of possible extentions to the CRC to avoid dialect problems.
            crc = MAVLinkCrc.CrcAccumulate(packetInfo.CrcExtra, crc);
            _isCRCValid = _crcBytes == crc;
        }

        /// <summary>
        ///     Constructor to create and encode a MAVLinkPacket to be send.
        ///     It assumes the provided payload is a valid <see cref="MAVLinkMessage"/> payload object that is correctly filled
        ///     and will immediately serialize the packet to a byte array <seealso cref="Bytes"/>.
        /// </summary>
        /// <param name="payload">MAVLinkMessage type object</param>
        /// <param name="systemId">System ID of the source (this) system sending the message. NOTE: may not be 0</param>
        /// <param name="componentId">Component ID of the source (this) system sending the message. NOTE: May not be <see cref="MAV_COMPONENT.MAV_COMP_ID_ALL"/></param>
        /// <param name="sequenceNumber">Incremented sequence number of the packet.</param>
        /// <exception cref="ArgumentException">Thrown when SystemID, ComponentID or payload are invalid!</exception>
        public MAVLinkPacket(MAVLinkMessage payload, byte systemId, MAV_COMPONENT componentId, byte sequenceNumber)
        {
            if (systemId == 0) throw new ArgumentException("SystemID is not allowed to be 0", nameof(systemId));
            if (MAV_COMPONENT.MAV_COMP_ID_ALL.Equals(componentId)) throw new ArgumentException("ComponentId is not allowed to be: " + MAV_COMPONENT.MAV_COMP_ID_ALL, nameof(componentId));
            if (!MAVLinkDeserializer.Lookup.ContainsKey(payload.MsgId)) throw new ArgumentException("Invalid/Unknwon Payload message type!");

            TimeStamp = DateTime.Now;
            _paload = payload;

            // Make sure payload flag is also set to the right version.
            payload.IsMavlink2 = IsMavLinkV2;

            // Prepare payload by serializing to data array
            byte[] payloadData = payload.Serialize();

            // Trim the payload byte array (if neccesary) to correct size.
            TrimPayload(ref payloadData);

            // create byte array with correct size
            Bytes = new byte[GetPacketSizeForMessage(payloadData.Length)];

            // Fill message header information
            Bytes[MAVLINK_OFFSET_STX] = MAVLINK_STX;
            Bytes[MAVLINK_OFFSET_LEN] = (byte)payloadData.Length;
            Bytes[MAVLINK_OFFSET_SEQNR] = sequenceNumber;
            Bytes[MAVLINK_OFFSET_SYS_ID] = systemId;
            Bytes[MAVLINK_OFFSET_COMP_ID] = (byte)componentId;

            // Fill message ID field (can be up to 3 bytes for MavLink V2)
            for (var i = 0; i < MAVLINK_MSG_ID_LEN; i++)
                Bytes[MAVLINK_OFFSET_MESG_ID + i] = (byte)(Payload.MsgId >> (i * 8));

            // Add payload bytes
            Array.Copy(payloadData, 0, Bytes, MAVLINK_OFFSET_PAYLOAD, PayloadSize);

            // Note: CRC needs to exclude the magic (version) byte at the beginning (start offset +1 and totalsize -1)
            var crc = MAVLinkCrc.Calculate(Bytes, 1, MAVLINK_HEADER_LEN + PayloadSize - 1);

            // Determine and caluclate Extra CRC
            var extra = MAVLinkDeserializer.Lookup[Payload.MsgId];
            crc = MAVLinkCrc.CrcAccumulate(extra.CrcExtra, crc);
            _crcBytes = crc;

            // Fill CRC bytes
            Bytes[MAVLINK_OFFSET_CRC] = (byte)(_crcBytes & 0xFF);
            Bytes[MAVLINK_OFFSET_CRC + 1] = (byte)(_crcBytes >> 8);
        }

        /// <summary>
        ///     Method to calculate the total packet size including, header and payload size.
        ///     This is required for creating a correctly sized byte array.
        /// </summary>
        /// <param name="payloadSize">Size of payload</param>
        /// <returns>Total packet size</returns>
        protected internal virtual int GetPacketSizeForMessage(int payloadSize)
        {
            return MAVLINK_NONPAYLOAD_LEN + payloadSize;
        }

        /// <summary>
        ///     Method to trim the payload byte array if neccesary.
        /// </summary>
        /// <param name="payload">Reference to payload byte array that needs truncation</param>
        /// <returns>Truncated byte array.</returns>
        protected internal virtual byte[] TrimPayload(ref byte[] payload)
        {
            // MAVLink V1 packets do not require any trimming, so it returns the same array.
            return payload;
        }
    }
}
