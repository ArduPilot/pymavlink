#!/usr/bin/env python
"""
parse a MAVLink protocol XML file and generate a python implementation

Copyright Andrew Tridgell 2011
Released under GNU GPL version 3 or later
"""
from __future__ import print_function

from builtins import range

import os
import textwrap
from . import mavtemplate

t = mavtemplate.MAVTemplate()


def generate_preamble(outf, msgs, basename, args, xml):
    print("Generating preamble")
    t.write(
        outf,
        '''
# MAVLink protocol implementation (auto-generated by mavgen.py)
#
# Generated from: ${FILELIST}
#
# Note: this file has been auto-generated. DO NOT EDIT

import hashlib
import json
import os
import struct
import time
from typing import BinaryIO, Callable, Dict, List, Optional, Sequence, Tuple, Type, Union, cast

WIRE_PROTOCOL_VERSION = "${WIRE_PROTOCOL_VERSION}"
DIALECT = "${DIALECT}"

PROTOCOL_MARKER_V1 = 0xFE
PROTOCOL_MARKER_V2 = 0xFD
HEADER_LEN_V1 = 6
HEADER_LEN_V2 = 10

MAVLINK_SIGNATURE_BLOCK_LEN = 13

MAVLINK_IFLAG_SIGNED = 0x01

# allow MAV_IGNORE_CRC=1 to ignore CRC, allowing some
# corrupted msgs to be seen
MAVLINK_IGNORE_CRC = os.environ.get("MAV_IGNORE_CRC", 0)

# some base types from mavlink_types.h
MAVLINK_TYPE_CHAR = 0
MAVLINK_TYPE_UINT8_T = 1
MAVLINK_TYPE_INT8_T = 2
MAVLINK_TYPE_UINT16_T = 3
MAVLINK_TYPE_INT16_T = 4
MAVLINK_TYPE_UINT32_T = 5
MAVLINK_TYPE_INT32_T = 6
MAVLINK_TYPE_UINT64_T = 7
MAVLINK_TYPE_INT64_T = 8
MAVLINK_TYPE_FLOAT = 9
MAVLINK_TYPE_DOUBLE = 10


class x25crc:
    """CRC-16/MCRF4XX - based on checksum.h from mavlink library"""

    def __init__(self, buf: Union[bytes, bytearray, None] = None) -> None:
        self.crc = 0xFFFF
        if buf is not None:
            self.accumulate(buf)

    def accumulate(self, buf: Union[bytes, bytearray]) -> None:
        """add in some more bytes"""
        accum = self.crc
        for b in buf:
            tmp = b ^ (accum & 0xFF)
            tmp = (tmp ^ (tmp << 4)) & 0xFF
            accum = (accum >> 8) ^ (tmp << 8) ^ (tmp << 3) ^ (tmp >> 4)
        self.crc = accum


# swiped from DFReader.py
def to_string(s: Union[bytes, bytearray]) -> str:
    """desperate attempt to convert a string regardless of what garbage we get"""
    try:
        return s.decode("utf-8")
    except Exception:
        # so it's a nasty one. Let's grab as many characters as we can
        return s.decode("ascii", "ignore") + "_XXX"


class MAVLink_header:
    """MAVLink message header"""

    def __init__(
        self,
        msgId: int,
        incompat_flags: int = 0,
        compat_flags: int = 0,
        mlen: int = 0,
        seq: int = 0,
        srcSystem: int = 0,
        srcComponent: int = 0,
    ) -> None:
        self.mlen = mlen
        self.seq = seq
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.msgId = msgId
        self.incompat_flags = incompat_flags
        self.compat_flags = compat_flags

    def pack(self, force_mavlink1: bool = False) -> bytes:
        if WIRE_PROTOCOL_VERSION == "2.0" and not force_mavlink1:
            return struct.pack(
                "<BBBBBBBHB",
                ${PROTOCOL_MARKER},
                self.mlen,
                self.incompat_flags,
                self.compat_flags,
                self.seq,
                self.srcSystem,
                self.srcComponent,
                self.msgId & 0xFFFF,
                self.msgId >> 16,
            )
        return struct.pack(
            "<BBBBBB",
            PROTOCOL_MARKER_V1,
            self.mlen,
            self.seq,
            self.srcSystem,
            self.srcComponent,
            self.msgId,
        )


class MAVLink_message:
    """base MAVLink message class"""

    id = 0
    msgname = ""
    fieldnames: List[str] = []
    ordered_fieldnames: List[str] = []
    fieldtypes: List[str] = []
    fielddisplays_by_name: Dict[str, str] = {}
    fieldenums_by_name: Dict[str, str] = {}
    fieldunits_by_name: Dict[str, str] = {}
    format = ""
    native_format = bytearray("", "ascii")
    orders: List[int] = []
    lengths: List[int] = []
    array_lengths: List[int] = []
    crc_extra = 0
    unpacker = struct.Struct("")
    instance_field: Optional[str] = None
    instance_offset = -1

    def __init__(self, msgId: int, name: str) -> None:
        self._header = MAVLink_header(msgId)
        self._payload: Union[bytes, bytearray, None] = None
        self._msgbuf: Union[bytes, bytearray, None] = None
        self._crc: Optional[int] = None
        self._fieldnames: List[str] = []
        self._type = name
        self._signed = False
        self._link_id: Optional[int] = None
        self._instances: Optional[Dict[str, str]] = None
        self._instance_field: Optional[str] = None

    def format_attr(self, field: str) -> Union[str, float, int]:
        """override field getter"""
        raw_attr: Union[bytes, str, float, int] = cast(
            Union[bytes, float, int],
            getattr(self, field),
        )
        if isinstance(raw_attr, bytes):
            raw_attr = to_string(raw_attr).rstrip("\\00")
        return raw_attr

    def get_msgbuf(self) -> bytearray:
        if self._msgbuf is None:
            raise TypeError("_msgbuf is not initialized")
        if isinstance(self._msgbuf, bytearray):
            return self._msgbuf
        return bytearray(self._msgbuf)

    def get_header(self) -> MAVLink_header:
        return self._header

    def get_payload(self) -> Union[bytes, bytearray, None]:
        return self._payload

    def get_crc(self) -> Optional[int]:
        return self._crc

    def get_fieldnames(self) -> List[str]:
        return self._fieldnames

    def get_type(self) -> str:
        return self._type

    def get_msgId(self) -> int:
        return self._header.msgId

    def get_srcSystem(self) -> int:
        return self._header.srcSystem

    def get_srcComponent(self) -> int:
        return self._header.srcComponent

    def get_seq(self) -> int:
        return self._header.seq

    def get_signed(self) -> bool:
        return self._signed

    def get_link_id(self) -> Optional[int]:
        return self._link_id

    def __str__(self) -> str:
        key_values = [(a, self.format_attr(a)) for a in self._fieldnames]
        str_key_values = ", ".join([f"{a}: {v}" for (a, v) in key_values])
        return self._type + f"{self._type} {{{str_key_values}}}"

    def __ne__(self, other: object) -> bool:
        return not self.__eq__(other)

    def __eq__(self, other: object) -> bool:
        if other is None:
            return False

        if not isinstance(other, MAVLink_message):
            return False

        if self.get_type() != other.get_type():
            return False

        # We do not compare CRC because native code doesn't provide it
        # if self.get_crc() != other.get_crc():
        #    return False

        if self.get_seq() != other.get_seq():
            return False

        if self.get_srcSystem() != other.get_srcSystem():
            return False

        if self.get_srcComponent() != other.get_srcComponent():
            return False

        for a in self._fieldnames:
            if self.format_attr(a) != other.format_attr(a):
                return False

        return True

    def to_dict(self) -> Dict[str, Union[str, float, int]]:
        d: Dict[str, Union[str, float, int]] = {}
        d["mavpackettype"] = self._type
        for a in self._fieldnames:
            d[a] = self.format_attr(a)
        return d

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    def sign_packet(self, mav: "MAVLink") -> None:
        if self._msgbuf is None or mav.signing.secret_key is None:
            raise TypeError("_msgbuf is not initialized")

        h = hashlib.new("sha256")
        self._msgbuf += struct.pack("<BQ", mav.signing.link_id, mav.signing.timestamp)[:7]
        h.update(mav.signing.secret_key)
        h.update(self._msgbuf)
        sig = h.digest()[:6]
        self._msgbuf += sig
        mav.signing.timestamp += 1

    def pack_msg(
        self,
        mav: "MAVLink",
        crc_extra: int,
        payload: bytes,
        force_mavlink1: bool = False,
    ) -> bytes:
        plen = len(payload)
        if WIRE_PROTOCOL_VERSION != "1.0" and not force_mavlink1:
            # in MAVLink2 we can strip trailing zeros off payloads. This allows for simple
            # variable length arrays and smaller packets
            while plen > 1 and payload[plen - 1] == 0:
                plen -= 1
        self._payload = payload[:plen]
        incompat_flags = 0
        if mav.signing.sign_outgoing:
            incompat_flags |= MAVLINK_IFLAG_SIGNED
        self._header = MAVLink_header(
            self._header.msgId,
            incompat_flags=incompat_flags,
            compat_flags=0,
            mlen=len(self._payload),
            seq=mav.seq,
            srcSystem=mav.srcSystem,
            srcComponent=mav.srcComponent,
        )
        self._msgbuf = self._header.pack(force_mavlink1=force_mavlink1) + self._payload
        crc = x25crc(self._msgbuf[1:])
        if ${crc_extra}:  # using CRC extra
            crc.accumulate(struct.pack("B", crc_extra))
        self._crc = crc.crc
        self._msgbuf += struct.pack("<H", self._crc)
        if mav.signing.sign_outgoing and not force_mavlink1:
            self.sign_packet(mav)
        return self._msgbuf

    def pack(self, mav: "MAVLink", force_mavlink1: bool = False) -> bytes:
        raise NotImplementedError("MAVLink_message cannot be serialized directly")

    def __getitem__(self, key: str) -> str:
        """support indexing, allowing for multi-instance sensors in one message"""
        if self._instances is None:
            raise IndexError()
        if key not in self._instances:
            raise IndexError()
        return self._instances[key]

''',
        {
            "FILELIST": ",".join(args),
            "PROTOCOL_MARKER": xml.protocol_marker,
            "DIALECT": os.path.splitext(os.path.basename(basename))[0],
            "crc_extra": xml.crc_extra,
            "WIRE_PROTOCOL_VERSION": xml.wire_protocol_version,
        },
    )


def generate_enums(outf, enums):
    print("Generating enums")
    outf.write(
        """
# enums


class EnumEntry:
    def __init__(
        self,
        name: str,
        description: str,
        param: Optional[Dict[int, str]] = None,
    ) -> None:
        self.name = name
        self.description = description
        self.param: Dict[int, str]
        self.param = param if param is not None else {}


""")

    for e in enums:
        for entry in e.entry:
            outf.write("%s = %u\n" % (entry.name, entry.value))

    outf.write("""

enums = {
"""
    )
    for e in enums:
        outf.write(
            """    "%s": {"""
            % (e.name,)
        )
        for entry in e.entry:
            if len(entry.param) == 0:
                outf.write(
                    '''
        %s: EnumEntry(
            "%s",
            """%s""",
        ),''' % (
                    entry.name,
                    entry.name,
                    entry.description,
                ))
            else:
                params_dict = "{\n                %s,\n            }" % (
                    ",\n                ".join(
                        [
                            '%d: """%s"""' % (int(param.index), param.description)
                            for param in entry.param
                        ]
                    )
                )
                outf.write(
                    '''
        %s: EnumEntry(
            "%s",
            """%s""",
            %s,
        ),'''
                % (
                    entry.name,
                    entry.name,
                    entry.description,
                    params_dict,
                )
            )
        outf.write("\n    },\n")
    outf.write("}\n")


def generate_message_ids(outf, msgs):
    print("Generating message IDs")
    outf.write("\n# message IDs\n")
    outf.write("MAVLINK_MSG_ID_BAD_DATA = -1\n")
    outf.write("MAVLINK_MSG_ID_UNKNOWN = -2\n")
    for m in msgs:
        outf.write("MAVLINK_MSG_ID_%s = %u\n" % (m.name.upper(), m.id))


def byname_hash_from_field_attribute(m, attribute):
    strings = []
    for field in m.fields:
        value = getattr(field, attribute, None)
        if value is None or value == "":
            continue
        if attribute == "units":
            # hack; remove the square brackets further up
            if value[0] == "[":
                value = value[1:-1]
        strings.append('"%s": "%s"' % (field.name, value))
    return strings


def generate_classes(outf, msgs):
    print("Generating class definitions")
    wrapper = textwrap.TextWrapper(initial_indent="    ", subsequent_indent="    ")
    for m in msgs:
        classname = "MAVLink_%s_message" % m.name.lower()
        fieldname_str = ",\n        ".join(['"%s"' % s for s in m.fieldnames])
        ordered_fieldname_str = ",\n        ".join(['"%s"' % s for s in m.ordered_fieldnames])
        fielddisplays = byname_hash_from_field_attribute(m, "display")
        if len(fielddisplays) == 0:
            fielddisplays_str = "{}"
        else:
            fielddisplays_str = "{\n        " + ",\n        ".join(fielddisplays) + ",\n    }"

        fieldenums = byname_hash_from_field_attribute(m, "enum")
        if len(fieldenums) == 0:
            fieldenums_str = "{}"
        else:
            fieldenums_str = "{\n        " + ",\n        ".join(fieldenums) + ",\n    }"

        fieldunits = byname_hash_from_field_attribute(m, "units")
        if len(fieldunits) == 0:
            fieldunits_str = "{}"
        else:
            fieldunits_str = "{\n        " + ",\n        ".join(fieldunits) + ",\n    }"

        fieldtypes_str = ",\n        ".join(['"%s"' % s for s in m.fieldtypes])
        if m.instance_field is not None:
            instance_field = '"%s"' % m.instance_field
            instance_offset = m.field_offsets[m.instance_field]
        else:
            instance_field = "None"
            instance_offset = -1

        field_args = []
        for i in range(len(m.fields)):
            fname = m.fieldnames[i]
            if m.extensions_start is not None and i >= m.extensions_start:
                fdefault = m.fielddefaults[i]
                field_args.append("%s: %s = %s" % (fname, mavpytype(m.fields[i]), fdefault))
            else:
                field_args.append("%s: %s" % (fname, mavpytype(m.fields[i])))

        field_assignments = []
        for f in m.fields:
            field_assignments.append("self.%s = %s" % (f.name, f.name))

        self_fields = []
        for field in m.ordered_fields:
            if field.type != "char" and field.array_length > 1:
                for i in range(field.array_length):
                    self_fields.append("self.{0:s}[{1:d}]".format(field.name, i))
            else:
                self_fields.append("self.{0:s}".format(field.name))

        outf.write(
            '''

class %s(MAVLink_message):
    """
%s
    """

    id = MAVLINK_MSG_ID_%s
    msgname = "%s"
    fieldnames = [
        %s,
    ]
    ordered_fieldnames = [
        %s,
    ]
    fieldtypes = [
        %s,
    ]
    fielddisplays_by_name: Dict[str, str] = %s
    fieldenums_by_name: Dict[str, str] = %s
    fieldunits_by_name: Dict[str, str] = %s
    format = "%s"
    native_format = bytearray("%s", "ascii")
    orders = %s
    lengths = %s
    array_lengths = %s
    crc_extra = %s
    unpacker = struct.Struct("%s")
    instance_field = %s
    instance_offset = %d

    def __init__(
        self,
        %s,
    ) -> None:
        MAVLink_message.__init__(
            self,
            %s.id,
            %s.msgname,
        )
        self._fieldnames = %s.fieldnames
        self._instance_field = %s.instance_field
        self._instance_offset = %s.instance_offset
        %s

    def pack(self, mav: "MAVLink", force_mavlink1: bool = False) -> bytes:
        return self.pack_msg(
            mav,
            %u,
            struct.pack(
                "%s",
                %s,
            ),
            force_mavlink1=force_mavlink1,
        )
'''
            % (
                classname,
                wrapper.fill(m.description.strip()),
                m.name.upper(),
                m.name.upper(),
                fieldname_str,
                ordered_fieldname_str,
                fieldtypes_str,
                fielddisplays_str,
                fieldenums_str,
                fieldunits_str,
                m.fmtstr,
                m.native_fmtstr,
                m.order_map,
                m.len_map,
                m.array_len_map,
                m.crc_extra,
                m.fmtstr,
                instance_field,
                instance_offset,
                ",\n        ".join(field_args),
                classname,
                classname,
                classname,
                classname,
                classname,
                "\n        ".join(field_assignments),
                m.crc_extra,
                m.fmtstr,
                ",\n                ".join(self_fields),
            )
        )


def native_mavfmt(field):
    """work out the struct format for a type (in a form expected by mavnative)"""
    map = {
        "float": "f",
        "double": "d",
        "char": "c",
        "int8_t": "b",
        "uint8_t": "B",
        "uint8_t_mavlink_version": "B",
        "int16_t": "h",
        "uint16_t": "H",
        "int32_t": "i",
        "uint32_t": "I",
        "int64_t": "q",
        "uint64_t": "Q",
    }
    return map[field.type]


def mavpytype(field):
    c_type_to_py = {
        "float": "float",
        "double": "float",
        "char": "bytes",
        "int8_t": "int",
        "uint8_t": "int",
        "uint8_t_mavlink_version": "int",
        "int16_t": "int",
        "uint16_t": "int",
        "int32_t": "int",
        "uint32_t": "int",
        "int64_t": "int",
        "uint64_t": "int",
    }

    if field.array_length:
        if field.type == "char":
            return "bytes"
        return "Sequence[%s]" % c_type_to_py[field.type]
    return c_type_to_py[field.type]


def mavfmt(field):
    """work out the struct format for a type"""
    map = {
        "float": "f",
        "double": "d",
        "char": "c",
        "int8_t": "b",
        "uint8_t": "B",
        "uint8_t_mavlink_version": "B",
        "int16_t": "h",
        "uint16_t": "H",
        "int32_t": "i",
        "uint32_t": "I",
        "int64_t": "q",
        "uint64_t": "Q",
    }

    if field.array_length:
        if field.type == "char":
            return str(field.array_length) + "s"
        return str(field.array_length) + map[field.type]
    return map[field.type]


def mavdefault(field):
    """returns default value for field (as string) for mavlink2 extensions"""
    if field.type == "char":
        default_value = '""'
    else:
        default_value = "0"
    if field.array_length == 0:
        return default_value
    return "[" + ",".join([default_value] * field.array_length) + "]"


def generate_mavlink_class(outf, msgs, xml):
    print("Generating MAVLink class")

    outf.write("\n\nmavlink_map = {\n")
    for m in msgs:
        outf.write(
            "    MAVLINK_MSG_ID_%s: MAVLink_%s_message,\n" % (m.name.upper(), m.name.lower())
        )
    outf.write("}\n\n")

    t.write(
        outf,
        '''

class MAVError(Exception):
    """MAVLink error class"""

    def __init__(self, msg: str) -> None:
        Exception.__init__(self, msg)
        self.message = msg


class MAVString(str):
    """NUL terminated string"""

    def __init__(self, s: str) -> None:
        str.__init__(self)

    def __str__(self) -> str:
        i = self.find(chr(0))
        if i == -1:
            return self[:]
        return self[0:i]


class MAVLink_bad_data(MAVLink_message):
    """
    a piece of bad data in a mavlink stream
    """

    def __init__(self, data: Union[bytearray, bytes], reason: str) -> None:
        MAVLink_message.__init__(self, MAVLINK_MSG_ID_BAD_DATA, "BAD_DATA")
        self._fieldnames = ["data", "reason"]
        self.data = data
        self.reason = reason
        self._msgbuf = data
        self._instance_field: Optional[str] = None

    def __str__(self) -> str:
        """Override the __str__ function from MAVLink_messages because non-printable characters are common in to be the reason for this message to exist."""
        data = [f"{i:x}" for i in self.data]
        return f"{self._type} {{{self.reason}, data:{data}}}"


class MAVLink_unknown(MAVLink_message):
    """
    a message that we don't have in the XML used when built
    """

    def __init__(self, msgid: int, data: Union[bytearray, bytes]) -> None:
        MAVLink_message.__init__(self, MAVLINK_MSG_ID_UNKNOWN, f"UNKNOWN_{msgid}")
        self._fieldnames = ["data"]
        self.data = data
        self._msgbuf = data
        self._instance_field: Optional[str] = None

    def __str__(self) -> str:
        """Override the __str__ function from MAVLink_messages because non-printable characters are common."""
        data = [f"{i:x}" for i in self.data]
        return f"{self._type} {{data:{data}}}"


class MAVLinkSigning:
    """MAVLink signing state class"""

    def __init__(self) -> None:
        self.secret_key: Optional[bytes] = None
        self.timestamp = 0
        self.link_id = 0
        self.sign_outgoing = False
        self.allow_unsigned_callback: Optional[Callable[["MAVLink", int], bool]] = None
        self.stream_timestamps: Dict[Tuple[int, int, int], int] = {}
        self.sig_count = 0
        self.badsig_count = 0
        self.goodsig_count = 0
        self.unsigned_count = 0
        self.reject_count = 0


class MAVLink:
    """MAVLink protocol handling class"""

    def __init__(
        self,
        file: BinaryIO,
        srcSystem: int = 0,
        srcComponent: int = 0,
    ) -> None:
        self.seq = 0
        self.file = file
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.callback: Optional[Callable[[MAVLink_message], None]] = None
        self.send_callback: Optional[Callable[[MAVLink_message], None]] = None
        self.buf = bytearray()
        self.buf_index = 0
        self.expected_length = HEADER_LEN_V1 + 2
        self.have_prefix_error = False
        self.robust_parsing = False
        self.protocol_marker = ${protocol_marker}
        self.little_endian = ${little_endian}
        self.crc_extra = ${crc_extra}
        self.sort_fields = ${sort_fields}
        self.total_packets_sent = 0
        self.total_bytes_sent = 0
        self.total_packets_received = 0
        self.total_bytes_received = 0
        self.total_receive_errors = 0
        self.startup_time = time.time()
        self.signing = MAVLinkSigning()
        self.mav20_unpacker = struct.Struct("<cBBBBBBHB")
        self.mav10_unpacker = struct.Struct("<cBBBBB")
        self.mav20_h3_unpacker = struct.Struct("BBB")
        self.mav_csum_unpacker = struct.Struct("<H")
        self.mav_sign_unpacker = struct.Struct("<IH")

    def set_callback(self, callback: Callable[[MAVLink_message], None]) -> None:
        self.callback = callback

    def set_send_callback(self, callback: Callable[[MAVLink_message], None]) -> None:
        self.send_callback = callback

    def send(self, mavmsg: MAVLink_message, force_mavlink1: bool = False) -> None:
        """send a MAVLink message"""
        buf = mavmsg.pack(self, force_mavlink1=force_mavlink1)
        self.file.write(buf)
        self.seq = (self.seq + 1) % 256
        self.total_packets_sent += 1
        self.total_bytes_sent += len(buf)
        if self.send_callback:
            self.send_callback(mavmsg)

    def buf_len(self) -> int:
        return len(self.buf) - self.buf_index

    def bytes_needed(self) -> int:
        """return number of bytes needed for next parsing stage"""
        ret = self.expected_length - self.buf_len()

        if ret <= 0:
            return 1
        return ret

    def __callbacks(self, msg: MAVLink_message) -> None:
        """this method exists only to make profiling results easier to read"""
        if self.callback:
            self.callback(msg)

    def parse_char(self, c: bytes) -> Optional[MAVLink_message]:
        """input some data bytes, possibly returning a new message"""
        self.buf.extend(c)

        self.total_bytes_received += len(c)

        m = self.__parse_char_legacy()

        if m is not None:
            self.total_packets_received += 1
            self.__callbacks(m)
        else:
            # XXX The idea here is if we've read something and there's nothing left in
            # the buffer, reset it to 0 which frees the memory
            if self.buf_len() == 0 and self.buf_index != 0:
                self.buf = bytearray()
                self.buf_index = 0

        return m

    def __parse_char_legacy(self) -> Optional[MAVLink_message]:
        """input some data bytes, possibly returning a new message (uses no native code)"""
        m: MAVLink_message

        header_len = HEADER_LEN_V1
        if self.buf_len() >= 1 and self.buf[self.buf_index] == PROTOCOL_MARKER_V2:
            header_len = HEADER_LEN_V2

        if self.buf_len() >= 1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V2:
            magic = self.buf[self.buf_index]
            self.buf_index += 1
            if self.robust_parsing:
                m = MAVLink_bad_data(bytearray([magic]), "Bad prefix")
                self.expected_length = header_len + 2
                self.total_receive_errors += 1
                return m
            if self.have_prefix_error:
                return None
            self.have_prefix_error = True
            self.total_receive_errors += 1
            raise MAVError(f"invalid MAVLink prefix '{hex(magic)}'")
        self.have_prefix_error = False
        if self.buf_len() >= 3:
            sbuf = self.buf[self.buf_index : 3 + self.buf_index]
            (magic, self.expected_length, incompat_flags) = cast(
                Tuple[int, int, int],
                self.mav20_h3_unpacker.unpack(sbuf),
            )
            if magic == PROTOCOL_MARKER_V2 and (incompat_flags & MAVLINK_IFLAG_SIGNED):
                self.expected_length += MAVLINK_SIGNATURE_BLOCK_LEN
            self.expected_length += header_len + 2
        if self.expected_length >= (header_len + 2) and self.buf_len() >= self.expected_length:
            mbuf = self.buf[self.buf_index : self.buf_index + self.expected_length]
            self.buf_index += self.expected_length
            self.expected_length = header_len + 2
            if self.robust_parsing:
                try:
                    if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                        raise MAVError(f"invalid incompat_flags 0x{incompat_flags:x} 0x{magic:x} {self.expected_length}")
                    m = self.decode(mbuf)
                except MAVError as reason:
                    m = MAVLink_bad_data(mbuf, reason.message)
                    self.total_receive_errors += 1
            else:
                if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                    raise MAVError(f"invalid incompat_flags 0x{incompat_flags:x} 0x{magic:x} {self.expected_length}")
                m = self.decode(mbuf)
            return m
        return None

    def parse_buffer(self, s: bytes) -> Optional[List[MAVLink_message]]:
        """input some data bytes, possibly returning a list of new messages"""
        m = self.parse_char(s)
        if m is None:
            return None
        ret = [m]
        while True:
            m = self.parse_char(b"")
            if m is None:
                return ret
            ret.append(m)

    def check_signature(
        self,
        msgbuf: Union[bytearray, bytes],
        srcSystem: int,
        srcComponent: int,
    ) -> bool:
        """check signature on incoming message"""
        if self.signing.secret_key is None:
            raise TypeError("No secret key supplied")

        timestamp_buf = msgbuf[-12:-6]
        link_id = msgbuf[-13]
        (tlow, thigh) = cast(
            Tuple[int, int],
            self.mav_sign_unpacker.unpack(timestamp_buf),
        )
        timestamp = tlow + (thigh << 32)

        # see if the timestamp is acceptable
        stream_key = (link_id, srcSystem, srcComponent)
        if stream_key in self.signing.stream_timestamps:
            if timestamp <= self.signing.stream_timestamps[stream_key]:
                # reject old timestamp
                # print("old timestamp")
                return False
        else:
            # a new stream has appeared. Accept the timestamp if it is at most
            # one minute behind our current timestamp
            if timestamp + 6000 * 1000 < self.signing.timestamp:
                # print("bad new stream ", timestamp/(100.0*1000*60*60*24*365), self.signing.timestamp/(100.0*1000*60*60*24*365))
                return False
            self.signing.stream_timestamps[stream_key] = timestamp
            # print("new stream")

        h = hashlib.new("sha256")
        h.update(self.signing.secret_key)
        h.update(msgbuf[:-6])
        sig1 = h.digest()[:6]
        sig2 = msgbuf[-6:]
        if sig1 != sig2:
            # print("sig mismatch")
            return False

        # the timestamp we next send with is the max of the received timestamp and
        # our current timestamp
        self.signing.timestamp = max(self.signing.timestamp, timestamp)
        return True

    def decode(self, msgbuf: Union[bytes, bytearray]) -> MAVLink_message:
        """decode a buffer as a MAVLink message"""
        # decode the header
        if msgbuf[0] != PROTOCOL_MARKER_V1:
            headerlen = 10
            try:
                (magic, mlen, incompat_flags, compat_flags, seq, srcSystem, srcComponent, msgIdlow, msgIdhigh) = cast(
                    Tuple[bytes, int, int, int, int, int, int, int, int],
                    self.mav20_unpacker.unpack(msgbuf[:headerlen]),
                )
            except struct.error as emsg:
                raise MAVError(f"Unable to unpack MAVLink header: {emsg}")
            msgId = msgIdlow | (msgIdhigh << 16)
            mapkey = msgId
        else:
            headerlen = 6
            try:
                magic, mlen, seq, srcSystem, srcComponent, msgId = cast(
                    Tuple[bytes, int, int, int, int, int],
                    self.mav10_unpacker.unpack(msgbuf[:headerlen]),
                )
                incompat_flags = 0
                compat_flags = 0
            except struct.error as emsg:
                raise MAVError(f"Unable to unpack MAVLink header: {emsg}")
            mapkey = msgId
        if (incompat_flags & MAVLINK_IFLAG_SIGNED) != 0:
            signature_len = MAVLINK_SIGNATURE_BLOCK_LEN
        else:
            signature_len = 0

        if ord(magic) != PROTOCOL_MARKER_V1 and ord(magic) != PROTOCOL_MARKER_V2:
            raise MAVError(f"invalid MAVLink prefix '0x{magic.hex()}'")
        actual_msg_len = len(msgbuf) - (headerlen + 2 + signature_len)
        if mlen != actual_msg_len:
            raise MAVError(f"invalid MAVLink message length. Got {actual_msg_len} expected {mlen}, msgId={msgId} headerlen={headerlen}")

        if mapkey not in mavlink_map:
            return MAVLink_unknown(msgId, msgbuf)

        # decode the payload
        message_type: Type[MAVLink_message] = mavlink_map[mapkey]
        fmt = message_type.format
        order_map = message_type.orders
        len_map = message_type.lengths
        crc_extra = message_type.crc_extra

        # decode the checksum
        try:
            (crc,) = cast(
                Tuple[int],
                self.mav_csum_unpacker.unpack(msgbuf[-(2 + signature_len) :][:2]),
            )
        except struct.error as emsg:
            raise MAVError(f"Unable to unpack MAVLink CRC: {emsg}")
        crcbuf = bytearray(msgbuf[1 : -(2 + signature_len)])
        if ${crc_extra}:  # using CRC extra
            crcbuf.append(crc_extra)
        crc2 = x25crc(crcbuf)
        if crc != crc2.crc and not MAVLINK_IGNORE_CRC:
            raise MAVError(f"invalid MAVLink CRC in msgID {msgId} 0x{crc:04x} should be 0x{crc2.crc:04x}")

        sig_ok = False
        if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
            self.signing.sig_count += 1
        if self.signing.secret_key is not None:
            accept_signature = False
            if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
                sig_ok = self.check_signature(msgbuf, srcSystem, srcComponent)
                accept_signature = sig_ok
                if sig_ok:
                    self.signing.goodsig_count += 1
                else:
                    self.signing.badsig_count += 1
                if not accept_signature and self.signing.allow_unsigned_callback is not None:
                    accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                    if accept_signature:
                        self.signing.unsigned_count += 1
                    else:
                        self.signing.reject_count += 1
            elif self.signing.allow_unsigned_callback is not None:
                accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                if accept_signature:
                    self.signing.unsigned_count += 1
                else:
                    self.signing.reject_count += 1
            if not accept_signature:
                raise MAVError("Invalid signature")

        csize = message_type.unpacker.size
        mbuf = bytearray(msgbuf[headerlen : -(2 + signature_len)])
        if len(mbuf) < csize:
            # zero pad to give right size
            mbuf.extend([0] * (csize - len(mbuf)))
        if len(mbuf) < csize:
            raise MAVError(f"Bad message of type {message_type} length {len(mbuf)} needs {csize}")
        mbuf = mbuf[:csize]
        try:
            t = cast(
                Tuple[Union[bytes, int, float], ...],
                message_type.unpacker.unpack(mbuf),
            )
        except struct.error as emsg:
            raise MAVError(f"Unable to unpack MAVLink payload type={message_type} fmt={fmt} payloadLength={len(mbuf)}: {emsg}")

        tlist: List[Union[bytes, int, float, List[int], List[float]]] = list(t)
        # handle sorted fields
        if ${sort_fields}:
            tlist_saved = list(t)
            if sum(len_map) == len(len_map):
                # message has no arrays in it
                for i in range(0, len(tlist)):
                    tlist[i] = tlist_saved[order_map[i]]
            else:
                # message has some arrays
                tlist = []
                for i in range(0, len(order_map)):
                    order = order_map[i]
                    L = len_map[order]
                    tip = sum(len_map[:order])
                    field = tlist_saved[tip]
                    if L == 1 or isinstance(field, bytes):
                        tlist.append(field)
                    else:
                        tlist.append(
                            cast(
                                Union[List[float], List[int]],
                                tlist_saved[tip : (tip + L)],
                            )
                        )

        # terminate any strings
        tlist_str: List[Union[str, int, float, List[int], List[float]]] = []
        for i in range(0, len(tlist)):
            if message_type.fieldtypes[i] == "char":
                tlist_str.append(str(MAVString(to_string(cast(bytes, tlist[i])))))
            else:
                tlist_str.append(
                    cast(Union[int, float, List[float], List[int]], tlist[i]),
                )
        msg_tuple = tuple(tlist_str)
        try:
            # Note that initializers don't follow the Liskov Substitution Principle
            # therefore it can't be typechecked by mypy
            m = message_type(*msg_tuple)  # type: ignore
        except Exception as emsg:
            raise MAVError(f"Unable to instantiate MAVLink message of type {message_type} : {emsg}")
        m._signed = sig_ok
        if m._signed:
            m._link_id = msgbuf[-13]
        m._msgbuf = msgbuf
        m._payload = msgbuf[6 : -(2 + signature_len)]
        m._crc = crc
        m._header = MAVLink_header(
            msgId,
            incompat_flags,
            compat_flags,
            mlen,
            seq,
            srcSystem,
            srcComponent,
        )
        return m
''',
        xml,
    )


def generate_methods(outf, msgs):
    print("Generating methods")

    def field_descriptions(fields):
        ret = ""
        for f in fields:
            field_info = ""
            if f.units:
                field_info += "%s " % f.units
            field_info += "(type:%s" % f.type
            if f.enum:
                field_info += ", values:%s" % f.enum
            field_info += ")"
            ret += "        %-18s        : %s %s\n" % (
                f.name,
                f.description.strip(),
                field_info,
            )
        return ret

    wrapper = textwrap.TextWrapper(initial_indent="", subsequent_indent="        ")

    for m in msgs:
        comment = "%s\n\n%s" % (wrapper.fill(m.description.strip()), field_descriptions(m.fields))

        selffieldnames = ["self"]
        for i in range(len(m.fields)):
            f = m.fields[i]
            if f.omit_arg:
                selffieldnames.append("%s: %s = %s" % (f.name, mavpytype(f), f.const_value))
            elif m.extensions_start is not None and i >= m.extensions_start:
                fdefault = m.fielddefaults[i]
                selffieldnames.append("%s: %s = %s" % (f.name, mavpytype(f), fdefault))
            else:
                selffieldnames.append("%s: %s" % (f.name, mavpytype(f)))

        sub = {
            "NAMELOWER": m.name.lower(),
            "SELFFIELDNAMES": ",\n        ".join(selffieldnames),
            "COMMENT": comment,
            "FIELDNAMES3": ",\n            ".join(m.fieldnames),
            "FIELDNAMES4": ",\n                ".join(m.fieldnames),
        }

        t.write(
            outf,
            '''

    def ${NAMELOWER}_encode(
        ${SELFFIELDNAMES},
    ) -> MAVLink_${NAMELOWER}_message:
        """
        ${COMMENT}
        """
        return MAVLink_${NAMELOWER}_message(
            ${FIELDNAMES3},
        )
''',
            sub,
        )

        t.write(
            outf,
            '''

    def ${NAMELOWER}_send(
        ${SELFFIELDNAMES},
        force_mavlink1: bool = False,
    ) -> None:
        """
        ${COMMENT}
        """
        return self.send(
            self.${NAMELOWER}_encode(
                ${FIELDNAMES4},
            ),
            force_mavlink1=force_mavlink1,
        )
''',
            sub,
        )


def generate(basename, xml):
    """generate complete python implementation"""
    if basename.endswith(".py"):
        filename = basename
    else:
        filename = basename + ".py"

    msgs = []
    enums = []
    filelist = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)
        filelist.append(os.path.basename(x.filename))

    for m in msgs:
        m.fielddefaults = []
        if xml[0].little_endian:
            m.fmtstr = "<"
        else:
            m.fmtstr = ">"
        m.native_fmtstr = m.fmtstr
        m.instance_field = None
        for f in m.ordered_fields:
            m.fmtstr += mavfmt(f)
            m.fielddefaults.append(mavdefault(f))
            m.native_fmtstr += native_mavfmt(f)
            if f.instance:
                m.instance_field = f.name
        m.order_map = [0] * len(m.fieldnames)
        m.len_map = [0] * len(m.fieldnames)
        m.array_len_map = [0] * len(m.fieldnames)
        for i in range(0, len(m.fieldnames)):
            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])
            m.array_len_map[i] = m.ordered_fields[i].array_length
        for i in range(0, len(m.fieldnames)):
            n = m.order_map[i]
            m.len_map[n] = m.fieldlengths[i]

    print("Generating %s" % filename)
    outf = open(filename, "w")
    generate_preamble(outf, msgs, basename, filelist, xml[0])
    generate_enums(outf, enums)
    generate_message_ids(outf, msgs)
    generate_classes(outf, msgs)
    generate_mavlink_class(outf, msgs, xml[0])
    generate_methods(outf, msgs)
    outf.close()
    print("Generated %s OK" % filename)
